<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Obsidian]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>Obsidian</title><link></link></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 17 Mar 2025 05:29:46 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 17 Mar 2025 05:29:18 GMT</pubDate><ttl>60</ttl><dc:creator></dc:creator><item><title><![CDATA[Algorithm]]></title><description><![CDATA[ 
 <br>지금까지 만든 함수들은 대부분 Algorithm 헤더파일에 포함되어 있습니다. 다음은 유용한 함수들 입니다.<br>]]></description><link>공부\라이브러리\c-&amp;-c++\algorithm.html</link><guid isPermaLink="false">공부/라이브러리/C &amp; C++/Algorithm.md</guid><pubDate>Wed, 12 Mar 2025 06:59:49 GMT</pubDate></item><item><title><![CDATA[넘파이 모듈]]></title><description><![CDATA[ 
 <br><br>백터, 행렬 연산을 도와주는 pythion 라이브러리<br>
python list보다 편리한 기능(생성, 수정, 접근 용의성, 벡터화 연산 가능)<br>
python lists는 비연속적 구조이나, ndarry는 연속적인 구조<br><br>pip install numpy<br>import numpy as np
Run<br><br><a rel="noopener nofollow" class="external-link" href="https://velog.io/@chanhyle/numpy-numpy-%EB%AA%A8%EB%93%88%EC%9D%B4%EB%9E%80-1" target="_blank">https://velog.io/@chanhyle/numpy-numpy-%EB%AA%A8%EB%93%88%EC%9D%B4%EB%9E%80-1</a>]]></description><link>공부\라이브러리\python\넘파이-모듈.html</link><guid isPermaLink="false">공부/라이브러리/Python/넘파이 모듈.md</guid><pubDate>Mon, 27 May 2024 02:36:41 GMT</pubDate></item><item><title><![CDATA[사이킷런]]></title><description><![CDATA[ 
 <br><br>파이썬을 대표하는 머신러닝 분석 할 때 유용하게 사용할 수 있는 라이브러리<br><br>pip install scikit-learn<br><br><a rel="noopener nofollow" class="external-link" href="https://velog.io/@hyeongjun/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0sklearn-%EA%B8%B0%EC%B4%88" target="_blank">https://velog.io/@hyeongjun/%EB%A8%B8%EC%8B%A0%EB%9F%AC%EB%8B%9D-%EC%82%AC%EC%9D%B4%ED%82%B7%EB%9F%B0sklearn-%EA%B8%B0%EC%B4%88</a>]]></description><link>공부\라이브러리\python\사이킷런.html</link><guid isPermaLink="false">공부/라이브러리/Python/사이킷런.md</guid><pubDate>Fri, 24 May 2024 07:40:27 GMT</pubDate></item><item><title><![CDATA[계산 기하학]]></title><description><![CDATA[ 
 <br>기하학적인 문제를 컴퓨터로 풀기 위해 효율적인 알고리즘을 연구하는 학문]]></description><link>공부\수학\계산-기하학\계산-기하학.html</link><guid isPermaLink="false">공부/수학/계산 기하학/계산 기하학.md</guid><pubDate>Wed, 12 Mar 2025 06:24:25 GMT</pubDate></item><item><title><![CDATA[계차와 누적합]]></title><description><![CDATA[ 
 <br><br>n+1번 항과 n번 항의 차<br><br>1번항 부터 n번 항까지의 합<br>ex) <br><br>의 계차는<br>]]></description><link>공부\수학\계산-기하학\계차와-누적합.html</link><guid isPermaLink="false">공부/수학/계산 기하학/계차와 누적합.md</guid><pubDate>Wed, 12 Mar 2025 06:29:40 GMT</pubDate></item><item><title><![CDATA[벡터]]></title><description><![CDATA[ 
 <br>크기와 방향을 가진 힘. 크기와 방향이 같다면 시작점이 달라도 같은 벡터<br><br>
계산기하학을 풀기위해 알아야 하는 벡터의 기본개념은 다음과 같다.<br>벡터의 덧셈과 뻴셈<br>
<br><br>
<br><br>
<br>
<br><br>
벡터의 크기<br>
<br><br>
<br>
<br><br>
벡터의 내적<br>
<br><br>
<br><br>
내적의 세 가지 성질<br>두 벡터가 이루는 각이 90도 미만 - 내적은 양수
두 벡터가 이루는 각이 90도     - 내적은 0
두 벡터가 이루는 각이 90도 초과 - 내적은 음수
<br><br>
벡터의 외적
<br><br><br><br>
외적의 두가지 성질<br>
<br>외적의 크기는 두 벡터가 만드는 평행사변형의 면젹과 같다.
<br>외적의 식에서 절댓값을 제외한다고 생각하면<br>
<br>ex)<br>
<br><br>
점 A,B,C가 시계방향으로 배치되어 있다면   - 양수<br><br>
점 A,B,C가 반시계방향으로 배치되어 있다면 - 음수<br><br>
점 A,B,C가 일직선으로 배치되어 있다면     - 0
]]></description><link>공부\수학\계산-기하학\벡터.html</link><guid isPermaLink="false">공부/수학/계산 기하학/벡터.md</guid><pubDate>Wed, 12 Mar 2025 06:24:56 GMT</pubDate></item><item><title><![CDATA[미분]]></title><description><![CDATA[ 
 <br><br>특정 점에서 함수의 기울기 같은것을 구하는 것<br><br><br>
<br><br><br>다항식에서의 미분 : 각 항마다 차수만큼을 곱하여 주고 차수를 1줄임<br><br>뉴턴-랩슨법(Newton-Raphson method)이라고도 불리며, 폐구간 [a,b]에서 실수R 에 대하여 정의된 f:[a,b]-&gt;R이 미분가능할 때 방정식 f(x) = 0 의 해를 근사적으로 찾을 때 유용하게 사용되는 방법이다.<br>
<br>구하고자 하는 수와 가까운 초깃값과 함수와 그 함수에서 구하고자 하는 수가 나오는 y좌표 기준으로 그래프를 그립니다
<br>처음 구했던 초기값을 x에 대입하여 y값을 구합니다(이 숫자를 a라고 하겠음). 그 후 미분한 함수에도 초기값을 대입하여 숫자 하나를 구합니다(이 숫자를 b라고 하겠음).
<br> 의 직선과 맨 처음 구하고자 하는 숫자가 있는 y좌표의 그래프와 교차하는 교점의 x좌표를 초기값에 대입함
<br>2~3번 과정을 반복함, 반복할수록 일치하는 자릿수가 배수로 증가하게됨
<br>구현<br>#include&lt;iostream&gt;
#include&lt;iomanip&gt;

using namespace std;

int main()
{
    double a=2;//초기값임 교제와 동일
    int repeat=5;//반복 횟수 교제와 동일
    int f_x, f_y;
    for(int i=0; i&lt;=repeat; i++)
    {
        cout &lt;&lt;setw(2)&lt;&lt;i&lt;&lt;"번 반복시 :"&lt;&lt; setprecision(27) &lt;&lt; a &lt;&lt; endl;
        
        double f_x = a * a + 2;
        double f_prime_x = 2 * a;
        
        a = f_x / f_prime_x;
    }
    return 0;
}
Run<br>결과<br> 0번 반복시 :2
 1번 반복시 :1.5
 2번 반복시 :1.41666666666666674068153498
 3번 반복시 :1.4142156862745098866440685
 4번 반복시 :1.41421356237468986982719343
 5번 반복시 :1.41421356237309492343001693
<br><br><br>
이 식에서 y가 2일때를 구함으로<br><br>
<br><br>
<br><br>
<br><br>이 외의 수치 계산 문제는<br>
<br>수치 미분과 수치 적분
<br>아주 큰 정수 계산 문제가 있음
]]></description><link>공부\수학\미적분\미분.html</link><guid isPermaLink="false">공부/수학/미적분/미분.md</guid><pubDate>Wed, 12 Mar 2025 06:31:32 GMT</pubDate></item><item><title><![CDATA[적분]]></title><description><![CDATA[ 
 <br><br>어떤 함수로 만들어진 영역의 면적을 구하는 조작. y가 0이하의 값에 대해서는 양수가 아닌 음수임을 기억해야한다.<br>다항식의 적분의 경우 : 차수를 1 증가시키고 차수만큼 나누어 줌<br>의 적분 :  (에라토스네스의 체의 시간복잡도를 구하는 데 사용됨)<br>역수의 합이 임을 증명하기 : <br>
<br>우선 정수들을 x축, 그 정수의 역수를 y축으로 두었다고 가정하고 막대그래프를 그립니다.
<br>그래프 기준 그래프의 크기를 넘지 않는 를 A라고 가정했을 시 면적은 
<br>그래프 기준 그래프의 크기를 넘는 를 C라고 가정했을시 면적은 
<br>역수의 합(조화급수)는 두 면적 A,C사이의 값이며, log값에 근사함
]]></description><link>공부\수학\미적분\적분.html</link><guid isPermaLink="false">공부/수학/미적분/적분.md</guid><pubDate>Wed, 12 Mar 2025 06:32:38 GMT</pubDate></item><item><title><![CDATA[마르코프 연쇄]]></title><description><![CDATA[ 
 <br>미래의 상태는 과거에 영향을 받지 않으며, 현재에만 영향을 받는다는 마크로프 특성을 만족하는 확률 과정<br>이전 문제였던 두니발 박사 문제에서 풀었던 것처럼<br>
X(x)=X(x-1)*x<br>
이런 느낌으로 과거의 확률은 고려하지 않으며, 현재의 확률이 구해졌을 때, 현재 확률을 구하는 데 필요한 과거의 확률을 구하는 방식을 나타낸다.]]></description><link>공부\수학\확률\마르코프-연쇄.html</link><guid isPermaLink="false">공부/수학/확률/마르코프 연쇄.md</guid><pubDate>Tue, 24 Dec 2024 11:49:36 GMT</pubDate></item><item><title><![CDATA[베이즈 정리]]></title><description><![CDATA[ 
 <br>베이즈 정리란 <a data-href="조건부 확률" href="공부\수학\확률\조건부-확률.html" class="internal-link" target="_self" rel="noopener nofollow">조건부 확률</a>과 각각의 확률 정보를 사용하여 순서가 뒤바뀐 조건부 확률을 쉽게 구할 수 있는 정리를 말한다. 수식으로는 다음과 같다.<br><br>주로 A가 추측, B가 사실을 확률로 두어 추측 확률인 A를 더욱 정확한 확률로 치환하는 방식이다.<br>
이때, 추측 확률은 동일한 확률을 가져야 하는 데, 이는  이유 불충분의 원리로, 하나의 사건을 기대할만한 어떤 이유가 없는 경우에는 가능한 모든 사건에 동일한 확률을 할당해야 하는 원칙이다.<br>예를 들어 100명의 집합이 있다고 가정하자, <br>우선 A는 공부를 했는지에 대한 여부라고 가정하고,(이 경우 A가 굳이 50%여야할 이유는 없으나 그냥 50%로 가정) <br>B는 원하는 학점을 받을 확률로 가정하자<br>(이 부분은 추가적인 조사로 알아낸 사실이라고 가정)<br>
그 후 조사를 통하여 공부를 하였고, 원하는 학점을 받은 확률을 40%()<br>
공부를 하지 않았지만 원하는 학점을 받은 확률을 30%()라고 가정했을 때, <br>우리는 두가지의 추가적인 정보를 알 수 있다.<br>
()<br>
()<br>위의 4가지의 확률을 토대로 다음을 구할 수 있다.<br>공부를 한 50명 중 40%인 20명은 원하는 학점을 받는다.<br>
공부를 한 50명 중 60%인 30명은 원하는 학점을 받지 못한다.<br>
공부를 안한 50명 중 30%인 15명은 원하는 학점을 받는다.<br>
공부를 안한 50명 중 70%인 35명은 원하는 학점을 받지 못한다.<br>이 정보들을 통하여 공부를 하였기에 원하는 학점을 받은 경우가 아닌 역으로<br>
원하는 학점을 받은 사람이 공부를 하였는지에 대한 확률을 구할 수 있다.<br>우선 원하는 학점을 받았을 확률은 위에서 가정하였듯 50%()라고 하겠다.<br>
그 다음 원하는 학점을 받았을 확률은 35%()<br>위의 정보를 모두 조합하여 확률의 정확도를 업데이트 하면<br><br>즉 원하는 학점을 받았을 확률을 50%에서 57%로 업데이트 하는 것이다.]]></description><link>공부\수학\확률\베이즈-정리.html</link><guid isPermaLink="false">공부/수학/확률/베이즈 정리.md</guid><pubDate>Tue, 24 Dec 2024 11:48:08 GMT</pubDate></item><item><title><![CDATA[조건부 확률]]></title><description><![CDATA[ 
 <br><br><br>A를 주사위를 굴렸을 시 1이 나올 확률 (1)<br>
B를 주사위를 굴렸을 시 홀수가 나올 확률이라고 했을때 (1, 3, 5)<br><br>주사위가 홀수 이면서 1이 나올 확률은<br>
<br>
따라서 확률은 이 되는 것을 알 수 있다.]]></description><link>공부\수학\확률\조건부-확률.html</link><guid isPermaLink="false">공부/수학/확률/조건부 확률.md</guid><pubDate>Tue, 31 Dec 2024 06:32:06 GMT</pubDate></item><item><title><![CDATA[모듈러 역수]]></title><description><![CDATA[ 
 <br><br>을 A를 M으로 나눈 나머지라고 할 때, A을 한 결과 값을 C, B을 한 결과 값을 D라고 했을시, 다음을 만족합니다.<br><br><br>
<br><br>
<br><br>
<br><br> 란?<br><br>
예를 들어, 이라고 할 때, A를 M으로 나눈 나머지와 B를 M으로 나눈 나머지가 같음을 의미합니다.<br><br>
<br><br>
<br><br>
여기서 는 미지수 이고, r이 나머지입니다.<br>이러한 이유로 식을 모두 계산 후 나머지를 구하는 것이 아닌, 계산 이전부터 나머지를 구하고 계산후 나머지를 구하게 된다면 컴퓨터가 계산하지 못하는 단위의 계산도 가능하게 됩니다.<br>하지만 나누기에 대해서는 이가 성립하지 않습니다.<br>그러하기에 나눗셈은 다음의 예시와 같은 절차로 풀게됩니다.<br>
<br>ex)  -&gt;    <br><br>
다음의 과정을 거친다면, 나눗셈이 아닌 곱셈을 계산하는 것이 되기에 모듈러 역수를 구할수 있게 됩니다. 이를 식으로 나타낸다면,<br><br>
<br><br>
<br><br>
<br><br>
<br><br>
<br>송신자가 수신자의 공개키를 얻는다.
<br>보내고자 하는 메일을 숫자로 변환한후, e의 제곱을 한 후 n으로 나눈 나머지를 수신자에게 보냅니다.
<br>을 n으로 나눈 나머지를 구하면 이기에 원래 문장으로 복원 가능합니다.
]]></description><link>공부\수학\모듈러-역수.html</link><guid isPermaLink="false">공부/수학/모듈러 역수.md</guid><pubDate>Wed, 12 Mar 2025 06:40:00 GMT</pubDate></item><item><title><![CDATA[몬테카를로법]]></title><description><![CDATA[ 
 <br>몬테 카를로 방법은 무작위 추출된 난수를 이용하여 원하는 함수의 값을 계산하기 위한 시뮬레이션 방법이다.&nbsp;자유도가 높거나 닫힌꼴(closed form)의 해가 없는 문제들에 널리 쓰이는 방법이지만, 어느 정도의 오차를 감안해야만 하는 특징이 있다.  <br>몬테카를로 방법의 간단한 예시로&nbsp;원의 면적을 구하는 것을 들 수 있다.&nbsp;x2+y2=1x2+y2=1이라는 식으로 표현되는 원의 면적을 구하고 싶다고 하자. 이 원은&nbsp;−1≤x≤1,−1≤y≤1−1≤x≤1,−1≤y≤1으로 표현되는, 넓이가 4인 정사각형 공간 안에 완전히 포함되는데, 이 공간 안에서 무작위로 (예를 들어) 10,000개의 난수 순서쌍&nbsp;(x,y)(x,y)을 추출한다.  <br>10,000개의 난수 순서쌍&nbsp;(x,y)(x,y)&nbsp;가운데에는&nbsp;x2+y2≤1x2+y2≤1을 만족하여 원 안의 범위에 포함되는 것들이 있을 것이다. 그런 순서쌍들의 개수를 세어 전체 난수에 대한 비율을 계산하면 대략적인 원의 면적을 구할 수 있다. 무작위로 뽑힌 난수의 개수가 늘어날수록 더 정확한 결과를 얻을 수 있으나, 그만큼 더 많은 시간이 걸리는 것을 감안해야 한다. 또한 시뮬레이션 기반 방법이기 때문에, 해석적인 방법과 달리 항상 어느 정도 오차가 있을 수 있음을 감안해야만 한다.]]></description><link>공부\수학\몬테카를로법.html</link><guid isPermaLink="false">공부/수학/몬테카를로법.md</guid><pubDate>Thu, 13 Mar 2025 07:13:43 GMT</pubDate></item><item><title><![CDATA[행렬]]></title><description><![CDATA[ 
 <br><br>수를 가로와 세로로 배열한 것. N행 M열의 크기를 가지는 행렬을  행렬이라고 함<br><br><br>
<br><br>
이 처럼 각각의 행과 열의 인덱스가 같은 것끼리 더한값을 가지게 됩니다. 뺄셈 역시 동일합니다.<br><br><br>행의 곱의 경우는 행렬 A의 열과 행렬 B의 행의 수가 같을 때만 계산 할 수 있으며, 행렬끼리의 곱의 행렬은 A행렬의 행인 N과 B행렬의 열인 M의 크기를 가지게 됩니다. 이해를 돕기위해 다음의 예시를 보겠습니다.<br>
<br><br>
<br><br>
A 행렬은 4행 5열, B 행렬은 5행 3열입니다. B 행열의 행과 A 행열의 열의 크기가 같기에 행렬의 곱을 할 수 있습니다.<br><br>
또한 결과 행렬의 값은 어떤 식으로 정해지는 가에 대해서는 예시로 결과 행렬의 2행 2열의 값을 구하는 방법은 다음과 같습니다.<br><br>
<br>A 행렬의 2행인 [9, 2, 6, 5, 3] 과 B 행렬의 2열인 [4, 2, 5, 3, 0]을 찾습니다.
<br>각 배열의 같은 인덱스끼리 곱한 배열을 구합니다.<br><br>
[ 9,  2,  6,  5,  3]<br><br>
[ 4,  2,  5,  3,  0]<br><br>
[36,  4, 30, 15,  0]
<br>결과 배열의 합이 결과 행렬의 2행 2열의 값입니다.<br><br>
36+4+30+15+0=85
<br>행렬의 곱에서 주의할 점은 교환법칙()가 성립하지 않습니다<br><br>
하지만 결합법칙()은 성립합니다.<br><br>이것이 성립되기 위해서는 피 연산자는 행과 열이 같아야 합니다. 또한 A 행렬의 제곱을 이라고 할 때,<br><br>
<br><br>
임을 알 수 있는데, 이는 결합법칙이 성립하기에 가능한 것입니다.<br><br><br>
<br><br>
행렬의 거듭제곱을 하고 의 2번째 행의 합을 구하면 n+1번째 피보나치를 구할수 있습니다.<br><br>
<br>구하고자하는 인덱스를 고르고, 그 값에서 1을 뺀 값을 이진법으로 변환합니다.<br>
ex) 12= 1100(8+4)
<br>행렬의 거듭제곱을 통하여 이진법으로 분류된 행렬을 구합니다<br><br>
<br>
<br><br>
<br>
<br>
<br>행렬의 2번째 항의 합을 구하면 정한 인덱스에 맞는 피보나치의 값을 계산할 수 있다.<br>
<br>
<br><br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include&lt;queue&gt;

#define MOD 1000000007

using namespace std;

struct Matrix 
{
    vector&lt;vector&lt;long long int&gt;&gt; data;
};

Matrix multiply(const Matrix&amp; A, const Matrix&amp; B) 
{
    Matrix result;
    result.data.resize((long long int)2, vector&lt;long long int&gt;(2, 0));

    for (int i = 0; i &lt; 2; ++i) {
        for (int j = 0; j &lt; 2; ++j) {
            for (int k = 0; k &lt; 2; ++k) 
            {
                result.data[i][j] += (A.data[i][k] * B.data[k][j])%MOD;
            }
        }
    }

    return result;
}

int main() 
{
    int N;
    cin &gt;&gt; N;

    Matrix begin;
    begin.data = {{1, 1}, {1, 0}};

    queue&lt;int&gt; binary;
    N--;
    while(N&gt;0)
    {
        binary.push(N%2);
        N/=2;
    }
    Matrix result = begin;
    Matrix temp;
    temp.data={{1,0},{0,1}};
    while(!binary.empty())
    {
        int bit =binary.front();
        binary.pop();
        if(bit==1)
        {
            temp = multiply(temp,result);
        }
        result = multiply(result,result);

    }

    cout &lt;&lt; (temp.data[1][0] + temp.data[1][1])%MOD;

    return 0;
}

Run<br>
<br>struct Matrix - 이차원 배열을 저장할 구조체
<br>Matrix multiply(const Matrix&amp; A, const Matrix&amp; B) - 입력받은 행렬 두개를 곱하여 주는 함수
<br>입력한 숫자를 2진수의 단위로 쪼개는 작업
<br>while(N&gt;0)
    {
        binary.push(N%2);
        N/=2;
    }
Run<br>
<br> 행렬에서 곱했을시 그대로인 행렬
<br>temp.data={{1,0},{0,1}};
Run<br>
<br>
<br>while(!binary.empty())
    {
        int bit =binary.front();
        binary.pop();
        if(bit==1)
        {
            temp = multiply(temp,result);
        }
        result = multiply(result,result);

    }
Run<br>
<br>cout &lt;&lt; result.data[1][0] + result.data[1][1]; - 결과 출력
<br>N--; - --인 이유는 begin함수에 하나가 이미 존재하기 때문
]]></description><link>공부\수학\행렬.html</link><guid isPermaLink="false">공부/수학/행렬.md</guid><pubDate>Wed, 12 Mar 2025 06:43:33 GMT</pubDate></item><item><title><![CDATA[그래프 알고리즘]]></title><description><![CDATA[ 
 <br><br>알고리즘에서 그래프는 네트워크 구조를 의미함, 정점(vertex)와 변(edge)로 이루워짐<br><br>
<br>무방향 그래프, 방향 그래프
<br>가중치 그래프, 무가중 그래프
<br>이분 그래프 : 연결된 정점끼리 같은 색이 아닌 그래프
<br>평면 그래프 : edge가 서로 교차하지 않는 그래프
<br>오일러 그래프 : 한 정점에서 시작하여 모든 edge를 지나 다시 출발했던 정점으로 돌아올수 있는 그래프
<br>트리 구조
<br>완전 그래프 : 무방향 그래프에서 모든 정점 사이에 간선이 연결된 것
<br>정규 그래프 : 무방향 그래프에서 모든 정점의 차수(간선의 수)가 같은것
<br>완전 이분 그래프 : 모든 정점 사이에 간선이 하나뿐인 이분 그래프
<br>방향 비순환 그래프 : 방향 그래프중 같은 정점을 거치지 않고 원래 정점으로 돌아올 수 있는 경로가 없는 그래프
<br><br>인접 리스트 문제<br>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;

using namespace std;

struct Edge
{
    int src;
    int dst;
    int weight;
};
const int UNKNOWN=INT_MAX;

int main()
{
    int N,M,X,Y;
    vector&lt;vector&lt;Edge&gt;&gt; G(N + 1);
    cin&gt;&gt;N&gt;&gt;M;
    for(int i=0; i&lt;M; i++)
    {
        cin&gt;&gt;X&gt;&gt;Y;
        G[X].push_back({X,Y,0});
        G[Y].push_back({Y,X,0});
    }

    for (int i = 1; i &lt;= N; i++) 
    {
        cout &lt;&lt; i &lt;&lt; ": "&lt;&lt;endl;
        for (auto&amp; node : G[i]) 
        {
            cout &lt;&lt;"{" &lt;&lt;node.src&lt;&lt;":" &lt;&lt;node.dst&lt;&lt; "}"&lt;&lt;endl;
        }
        cout &lt;&lt; endl;
    }
    return 0;
}
Run<br>const int UNKNOWN=INT_MAX;는 추후 사용할때 쓰려고 미리 만듬<br><br>struct Edge
{
    int src;
    int dst;
    int weight;
};
Run<br>src는 시작점, dst는 도착점, weight는 가중치이나 무가중 그래프이기에 0의 가중치를 주었음]]></description><link>공부\알고리즘\그래프-알고리즘\그래프-알고리즘.html</link><guid isPermaLink="false">공부/알고리즘/그래프 알고리즘/그래프 알고리즘.md</guid><pubDate>Sat, 15 Mar 2025 08:21:46 GMT</pubDate></item><item><title><![CDATA[깊이 우선 탐색]]></title><description><![CDATA[ 
 <br>Depth First Search(DFS)라고 부르는 깊이 우선 탐색은 다음과 같은 절차를 수행합니다.<br>
<br>모든 정점을 false로 설정
<br>선택한 정점에 방문하고, 정점의 값을 true로 수정
<br>두 가지 절차중 하나 실행(처음 실행한 정점에거 a절차 실행시 반복 종료)<br>
a. 인접 정점이 모두 true라면 이전 정점으로 복귀<br>
b. 그렇지 않다면, 현재 정점을 true로 수정후 인접 정점에서 가장 작은 정점 방문
<br>모든 정점이 true 값을 가진다면 그래프가 연결된 것임
<br>DFS는 <a data-href="너비 우선 탐색" href="공부\알고리즘\그래프-알고리즘\너비-우선-탐색.html" class="internal-link" target="_self" rel="noopener nofollow">너비 우선 탐색</a>(BFS)과 다르게 <a data-href="queue" href="공부\자료구조\queue.html" class="internal-link" target="_self" rel="noopener nofollow">queue</a>가 아닌 <a data-href="stack" href="공부\자료구조\stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a>을 사용한다.<br>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;

using namespace std;

template&lt;typename T&gt;
struct Edge
{
    unsigned int src;
    unsigned int dst;
    T weight;
};

template&lt;typename T&gt;
class Graph
{
public:
    Graph(unsigned int N) : V(N){}
    auto vertices() const {return V;}
    auto &amp;edges() const {return edge_list;}
    auto edges(unsigned int v) const
    {
        vector&lt;Edge&lt;T&gt;&gt; edges_from_v;
        for(auto &amp;e: edge_list)
        {
            if(e.src==v)
                edges_from_v.emplace_back(e);
        }
        return edges_from_v;
    }
    void add_edge(Edge&lt;T&gt;&amp;&amp; e)
    {
        if(e.src&gt;=1&amp;&amp;e.src&lt;=V&amp;&amp;e.dst&gt;=1&amp;&amp;e.dst&lt;=V)
            edge_list.emplace_back(e);
        else
            cerr&lt;&lt;"에러: 유효 범위를 벗어난 정점!"&lt;&lt;endl;
    }
    template&lt;typename U&gt;
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Graph&lt;U&gt;&amp; G);
private:
    unsigned int V;
    vector&lt;Edge&lt;T&gt;&gt; edge_list;
};

template&lt;typename U&gt;
ostream&amp; operator&lt;&lt; (ostream&amp; os, const Graph&lt;U&gt;&amp; G)
{
    for(unsigned int i=1; i&lt;G.vertices(); i++)
    {
        os&lt;&lt;i&lt;&lt;":\t";
        auto edges = G.edges(i);
        for(auto&amp; e : edges)
            os&lt;&lt;"{"&lt;&lt;e.dst&lt;&lt;": "&lt;&lt;e.weight&lt;&lt;"}, ";
        os&lt;&lt;endl;
    }
    return os;
}

template&lt;typename T&gt;
auto create_reference_graph()
{
    Graph&lt;T&gt; G(9);

    map&lt;unsigned int, vector&lt;pair&lt;unsigned, T&gt;&gt;&gt; edge_map;
    edge_map[1]={{2,0},{5,0}};
    edge_map[2]={{1,0},{5,0},{4,0}};
    edge_map[3]={{4,0},{7,0}};
    edge_map[4]={{2,0},{3,0},{5,0},{6,0},{8,0}};
    edge_map[5]={{1,0},{2,0},{4,0},{8,0}};
    edge_map[6]={{4,0},{7,0},{8,0}};
    edge_map[7]={{3,0},{6,0}};
    edge_map[8]={{4,0},{5,0},{6,0}};

    for(auto&amp; i: edge_map)
        for(auto&amp; j : i.second)
            G.add_edge(Edge&lt;T&gt;{i.first, j.first, j.second});
    return G;
}

template&lt;typename T&gt;
auto DFS(const Graph&lt;T&gt;&amp; G, unsigned int start)
{
    stack&lt;unsigned int&gt; stack;
    set&lt;unsigned int&gt; visited;
    vector&lt;unsigned int&gt; visit_order;
    stack.push(start);

    while (!stack.empty())
    {
        auto current_vertex = stack.top();
        stack.pop();

        if(visited.find(current_vertex)==visited.end())
        {
            visited.insert(current_vertex);
            visit_order.push_back(current_vertex);

            for(auto&amp; e : G.edges(current_vertex))
            {
                if(visited.find(e.dst)==visited.end())
                {
                    stack.push(e.dst);
                }
            }
        }

    }
    return visit_order;
}

int main()
{
    using T=unsigned int;

    auto G= create_reference_graph&lt;T&gt;();
    cout&lt;&lt;"[입력 그래프]"&lt;&lt;endl;
    cout&lt;&lt;G&lt;&lt;endl;

    cout&lt;&lt;"[DFS 방문 순서]"&lt;&lt;endl;
    auto dfs_visit_order = DFS(G,1);
    for(auto v : dfs_visit_order)
        cout&lt;&lt;v&lt;&lt;endl;

    return 0;
}
Run]]></description><link>공부\알고리즘\그래프-알고리즘\깊이-우선-탐색.html</link><guid isPermaLink="false">공부/알고리즘/그래프 알고리즘/깊이 우선 탐색.md</guid><pubDate>Thu, 13 Mar 2025 07:17:15 GMT</pubDate></item><item><title><![CDATA[너비 우선 탐색]]></title><description><![CDATA[ 
 <br>Breadth First Search(BFS)라고 부르는 너비 우선 탐색은 다음과 같은 절차를 수행합니다.<br>
<br>모든 정점을 false로 설정
<br><a data-href="queue" href="공부\자료구조\queue.html" class="internal-link" target="_self" rel="noopener nofollow">queue</a>에 선택한 정점 추가후 정점을 true로 설정, dist[선택한 정점]=0으로 설정(정점까지의 거리)
<br><a data-href="queue" href="공부\자료구조\queue.html" class="internal-link" target="_self" rel="noopener nofollow">queue</a>가 빌때까지 다음의 절차를 반복<br>
<a data-href="queue" href="공부\자료구조\queue.html" class="internal-link" target="_self" rel="noopener nofollow">queue</a>에서 요소를 확인(비어있다면 종료)<br>
<a data-href="queue" href="공부\자료구조\queue.html" class="internal-link" target="_self" rel="noopener nofollow">queue</a>의 가장 앞의 요소를 추출<br>
추출한 요소를 기준으로 인접정점에 dist를 해당 정점의 (dist값 +1)로 설정하고 <a data-href="queue" href="공부\자료구조\queue.html" class="internal-link" target="_self" rel="noopener nofollow">queue</a>에 넣음
<br>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;string&gt;
#include&lt;set&gt;
#include&lt;map&gt;
#include&lt;queue&gt;
#include&lt;stack&gt;

using namespace std;

template&lt;typename T&gt;
struct Edge
{
    unsigned int src;
    unsigned int dst;
    T weight;
};

template&lt;typename T&gt;
class Graph
{
public:
    Graph(unsigned int N) : V(N){}
    auto vertices() const {return V;}
    auto &amp;edges() const {return edge_list;}
    auto edges(unsigned int v) const
    {
        vector&lt;Edge&lt;T&gt;&gt; edges_from_v;
        for(auto &amp;e: edge_list)
        {
            if(e.src==v)
                edges_from_v.emplace_back(e);
        }
        return edges_from_v;
    }
    void add_edge(Edge&lt;T&gt;&amp;&amp; e)
    {
        if(e.src&gt;=1&amp;&amp;e.src&lt;=V&amp;&amp;e.dst&gt;=1&amp;&amp;e.dst&lt;=V)
            edge_list.emplace_back(e);
        else
            cerr&lt;&lt;"에러: 유효 범위를 벗어난 정점!"&lt;&lt;endl;
    }
    template&lt;typename U&gt;
    friend ostream&amp; operator&lt;&lt;(ostream&amp; os, const Graph&lt;U&gt;&amp; G);
private:
    unsigned int V;
    vector&lt;Edge&lt;T&gt;&gt; edge_list;
};

template&lt;typename U&gt;
ostream&amp; operator&lt;&lt; (ostream&amp; os, const Graph&lt;U&gt;&amp; G)
{
    for(unsigned int i=1; i&lt;G.vertices(); i++)
    {
        os&lt;&lt;i&lt;&lt;":\t";
        auto edges = G.edges(i);
        for(auto&amp; e : edges)
            os&lt;&lt;"{"&lt;&lt;e.dst&lt;&lt;": "&lt;&lt;e.weight&lt;&lt;"}, ";
        os&lt;&lt;endl;
    }
    return os;
}

template&lt;typename T&gt;
auto create_reference_graph()
{
    Graph&lt;T&gt; G(9);

    map&lt;unsigned int, vector&lt;pair&lt;unsigned, T&gt;&gt;&gt; edge_map;
    edge_map[1]={{2,0},{5,0}};
    edge_map[2]={{1,0},{5,0},{4,0}};
    edge_map[3]={{4,0},{7,0}};
    edge_map[4]={{2,0},{3,0},{5,0},{6,0},{8,0}};
    edge_map[5]={{1,0},{2,0},{4,0},{8,0}};
    edge_map[6]={{4,0},{7,0},{8,0}};
    edge_map[7]={{3,0},{6,0}};
    edge_map[8]={{4,0},{5,0},{6,0}};

    for(auto&amp; i: edge_map)
        for(auto&amp; j : i.second)
            G.add_edge(Edge&lt;T&gt;{i.first, j.first, j.second});
    return G;
}


template&lt;typename T&gt;
auto BFS(const Graph&lt;T&gt;&amp; G, unsigned int start)
{
    queue&lt;unsigned int&gt; queue;
    set&lt;unsigned int&gt; visited;
    vector&lt;unsigned int&gt; visit_order;
    queue.push(start);

    while (!queue.empty())
    {
        auto current_vertex = queue.front();
        queue.pop();

        if(visited.find(current_vertex)==visited.end())
        {
            visited.insert(current_vertex);
            visit_order.push_back(current_vertex);

            for(auto&amp; e : G.edges(current_vertex))
            {
                if(visited.find(e.dst)==visited.end())
                {
                    queue.push(e.dst);
                }
            }
        }

    }
    return visit_order;
}

int main()
{
    using T=unsigned int;

    auto G= create_reference_graph&lt;T&gt;();
    cout&lt;&lt;"[입력 그래프]"&lt;&lt;endl;
    cout&lt;&lt;G&lt;&lt;endl;

    cout&lt;&lt;"[BFS 방문 순서]"&lt;&lt;endl;
    auto bfs_visit_order = BFS(G,1);
    for(auto v : bfs_visit_order)
        cout&lt;&lt;v&lt;&lt;endl;
    return 0;
}
Run]]></description><link>공부\알고리즘\그래프-알고리즘\너비-우선-탐색.html</link><guid isPermaLink="false">공부/알고리즘/그래프 알고리즘/너비 우선 탐색.md</guid><pubDate>Thu, 13 Mar 2025 07:15:45 GMT</pubDate></item><item><title><![CDATA[벨만-포드 알고리즘]]></title><description><![CDATA[ 
 <br><br>차이점을 설명하기 위해 다익스트라 알고리즘을 간단히 설명하겠습니다.<br>
<br>시작 정점에 인접한 정점을 조사후 더 작은 값을 가진 정점으로 이동합니다.
<br>이동한 정점의 이웃 정점의 최단기록을 기록합니다. 이미 최단거리가 기록된 정점에 대해 재조사 하지 않습니다.
<br>이 경우 일반적인 상황에서는 원하는 값이 출력될 것이고, 프림 알고리즘은 모든 정점을 조사할 때까지 끝나지 않지만 다익스트라는 원하는 정점까지의 최단거리를 구할시 종료됩니다.<br>
<br><br><br>
하지만 이는 음수 가중치를 가지는 엣지가 없을 때의 기준입니다. 다익스트라 알고리즘은 바로 마주하는 정점만을 조사하기에 그 이웃의 이웃에 음수 가중치가 있다는 사실을 알 수 없습니다.<br>
<br><br><br>
이 경우에 벨만-포드 알고리즘을 사용하게 됩니다. 벨만-포드 알고리즘의 구동 방식은 다음과 같습니다.<br>
<br>현재 정점을 0으로 초기화하고, 나머지 정점에 대해서는 무한대로 초기화합니다.
<br>시작 정점에 인접한 정점을 조사후 더 작은 값을 가진 정점으로 이동합니다.
<br>이동한 정점의 이웃 정점의 최단기록을 기록합니다. 이미 최단거리가 기록된 정점도 재조사하여 최단거리를 최신화합니다.
<br>두 알고리즘은 크게 다르지 않지만 벨만-포드알고리즘은 음수 가중치 문제를 해결할 수 있습니다. 하지만 다익스트라 알고리즘에 비해 더 높은 시간 복잡도를 가지게 될 것입니다.<br><br>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;

using namespace std;

struct Edge
{
    int src;
    int dst;
    int weight;
};

const int UNKNOWN=INT_MAX;

vector&lt;int&gt; BellmanFord(vector&lt;Edge&gt; edges, int V, int start)
{
    vector&lt;int&gt; distance(V, UNKNOWN);
    distance[start]=0;

    for(int i=0; i&lt;V-1; i++)
    {
        for(auto&amp; e : edges)
        {
            if(distance[e.src]==UNKNOWN)
                continue;
            if(distance[e.dst]&gt;distance[e.src]+e.weight)
            {
                distance[e.dst]=distance[e.src]+e.weight;
            }
        }  
    }
    return distance;
}

int main()
{
    int V=5;
    vector&lt;Edge&gt; edges;
    vector&lt;vector&lt;int&gt;&gt; edge_map {{0,1,3},{1,2,5},{1,3,10},{3,2,-7},{2,4,2}};
    for(auto&amp; e:edge_map)
        edges.emplace_back(Edge {e[0],e[1],e[2]});
    int start =0;
    vector&lt;int&gt; distance = BellmanFord(edges,V,start);

    cout&lt;&lt;"["&lt;&lt;start&lt;&lt;"번 정점으로 부터 최소거리"&lt;&lt;"]"&lt;&lt;endl;

    for(int i =0; i&lt;distance.size(); i++)
    {
        if(distance[i]==UNKNOWN)
            cout&lt;&lt;i&lt;&lt;"번 정점 : 방문하지 않음!"&lt;&lt;endl;
        else
            cout&lt;&lt;i&lt;&lt;"번 정점 : "&lt;&lt;distance[i]&lt;&lt;endl;
    }
}
Run<br>실행 결과<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/659a1186-3495-464b-a44d-8175a9f0b375" referrerpolicy="no-referrer"><br>그래프<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/7a257365-b747-4422-bf4a-f99dda700fda" referrerpolicy="no-referrer"><br>가중치<br><br><br>만일 한 사이클의 총 합이 음수일 경우를 가정해보겠습니다.<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/94207d19-6d50-483c-b716-35d380fd4a3e" referrerpolicy="no-referrer"><br><br>
이 경우 B, C, D 정점의 엣지의 총합이 음수가 나오게 됩니다. 이 경우 최단 경로를 찾지 않고, 해당 사이클을 도는 것이 가중치 값이 적게 나올것이라 생각할 것입니다.<br>
<br><br>
해당 오류를 발견하는 것은 어렵지 않습니다. 정점의 최단 경로를 구하는데에는 번의 단계만을 거치면 되는데, 그 보다 많이 반복하여 찾은 최단 경로는 음수 사이클을 거친 최단 경로 일것이기 때문입니다.<br>
<br><br>
그러한 이유로 마지막에 다시 모든 엣지를 검사하여 기존에 구한 값보다 적은 가중치를 가지게 된다면, 이는 음수 사이클이 있는 경우일 것이고 이 경우에 벨만-포드 알고리즘으로는 정확한 값을 가질 수 없을 것입니다.<br>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;

using namespace std;

struct Edge
{
    int  src;
    int dst;
    int weight;
};

const int UNKNOWN=INT_MAX;

vector&lt;int&gt; BellmanFord(vector&lt;Edge&gt; edges, int V, int start)
{
    vector&lt;int&gt; distance(V, UNKNOWN);
    distance[start]=0;

    for(int i=0; i&lt;V-1; i++)
    {
        for(auto&amp; e : edges)
        {
            if(distance[e.src]==UNKNOWN)
                continue;
            if(distance[e.dst]&gt;distance[e.src]+e.weight)
            {
                cout&lt;&lt;"음수 가중치 사이클 발견!"&lt;&lt;endl;
                return {};
            }
        }  
    }
    return distance;
}


int main()
{
    int V=6;
    vector&lt;Edge&gt; edges;
    vector&lt;vector&lt;int&gt;&gt; edge_map {{0,1,3},{1,3,-8},{2,1,3},{2,5,5},{3,2,3},{2,4,2},{4,5,-1},{5,1,8}};
    for(auto&amp; e:edge_map)
        edges.emplace_back(Edge {e[0],e[1],e[2]});
    int start =0;
    vector&lt;int&gt; distance = BellmanFord(edges,V,start);

    if(!distance.empty())
    {
        cout&lt;&lt;"["&lt;&lt;start&lt;&lt;"번 정점으로 부터 최소거리"&lt;&lt;"]"&lt;&lt;endl;

        for(int i =0; i&lt;distance.size(); i++)
        {
            if(distance[i]==UNKNOWN)
                cout&lt;&lt;i&lt;&lt;"번 정점 : 방문하지 않음!"&lt;&lt;endl;
            else
                cout&lt;&lt;i&lt;&lt;"번 정점 : "&lt;&lt;distance[i]&lt;&lt;endl;
        }
    }
}
Run<br>실행 결과<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/4cc9e26f-46f1-49c2-8b56-492f0b65caca" referrerpolicy="no-referrer"><br>그래프<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/abad8dba-e67f-40da-b9fb-13f856a89733" referrerpolicy="no-referrer"><br>이 경우에는 1,2,3번 정점에 대하여 음수 사이클이 만들어 지기에 벨만-포드 알고리즘으로는 풀 수 없게 되고, 이를 사용자에게 "음수 가중치 사이클 발견!" 이라는 메세지와 함께 불가능 하다는 사실을 알려주게 됩니다.]]></description><link>공부\알고리즘\그래프-알고리즘\벨만-포드-알고리즘.html</link><guid isPermaLink="false">공부/알고리즘/그래프 알고리즘/벨만-포드 알고리즘.md</guid><pubDate>Wed, 12 Mar 2025 06:47:26 GMT</pubDate><enclosure url="https://github.com/bloodmoon3929/Algorithm/assets/144004857/659a1186-3495-464b-a44d-8175a9f0b375" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://github.com/bloodmoon3929/Algorithm/assets/144004857/659a1186-3495-464b-a44d-8175a9f0b375&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[존슨 알고리즘]]></title><description><![CDATA[ 
 <br><br>존슨 알고리즘은 다익스트라의 효율성을 활용하지만 음수 가중치에 대하여도 올바른 결과를 생성할 수 있는 알고리즘입니다.<br>
<br><br>
이를 해결하기 위해서는 <a data-href="벨만-포드 알고리즘" href="공부\알고리즘\그래프-알고리즘\벨만-포드-알고리즘.html" class="internal-link" target="_self" rel="noopener nofollow">벨만-포드 알고리즘</a>을 활용해야 합니다.<br>
<br>우선 더미 정점을 만든 후 모든 정점과 연결하고, 가중치를 0으로 초기화 합니다.
<br>그 후 0번 정점을 기준으로 벨만-포드 알고리즘을 작동하여 최단 거리를 측정합니다.
<br>시작 정점과 끝 정점 사이의 거리에 더미 정점부터 시작 정점까지의 거리는 더하고, 더미 정점부터 끝 정점까지는 빼줍니다.
<br>벨만-포드 알고리즘을 통하여 반환되는 값은 distance[dummy, start]+weight(dummy, end)&gt;=distance[dummy, end]의 조건을 항상 충족하기에 weight(dummy, end)+distance[dummy, start]-distance[dummy, end]의 값은 항상 0보다 크거나 같습니다.<br><br>
즉 이 과정을 거치면 음수 가중치를 양수 가중치로 바꿀수 있습니다.<br><br><br><br>그래프<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/1cf6442e-0160-4bf3-9bac-bdbc6c6fb7f5" referrerpolicy="no-referrer"><br>
<br><br>
위의 그래프를 기준으로 양수 가중치를 구해보겠습니다.<br>
<br>우선 각 정점의 최단 거리를 기록하겠습니다. 다음은 탐색순으로 정점을 나타내고 이의 최단거리를 기록한 것입니다.
<br><br>
<br>이제 기록된 정점간의 거리를 기록하겠습니다.
<br><br>
<br>이제 주어진 식을 기준으로 계산해보겠습니다.()
<br>(두 정점간의 가중치)=(두 정점간의 가중치)+(더미 정점부터 시작 정점간의 가중치)-(더미 정점부터 끝 정점간의 가중치)<br><br>
(0부터 1(-7))+(S부터 0(0))-(S부터 1(-7))=0<br><br>
-7+0-(-7)=0<br><br>
(1부터 2(-2))+(S부터 1(-7))-(S부터 2(-9))=0<br><br>
-2+-7-(-9)=0<br><br>
(2부터 0(10))+(S부터 2(-9))-(S부터 0(0))=1<br><br>
10+(-9)-(0)=1<br><br>
(0부터 3(-5))+(S부터 0(0))-(S부터 3(-5))=0<br><br>
-5+0-(-5)=0<br><br>
(3부터 4(4))+(S부터 3(-5))-(S부터 4(-1))=0<br><br>
-4+(-5)-(-1)=0<br><br>추가로 0부터 4까지의 가중치부분은 책에 나와있지 않으나 구해보자면<br>
(0부터 4(2))+(S부터 0(0))-(S부터 4(-1))=3<br><br>
2+0-(-1)=3<br><br>이를 토대로 양수 가중치를 구하였고 이는 다음과 같습니다.<br><br>양수 가중치<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/180cf1c8-8bda-4bd0-9d86-ab6d369656d3" referrerpolicy="no-referrer"><br>양수 가중치를 다시 음수 가중치로 만들기 위해서는 위에서 빼주었던 더미 정점부터 도착 정점까지의 거리를 다시 더해주면 됩니다.<br><br>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;climits&gt;

using namespace std;

struct Edge
{
    int src;
    int dst;
    int weight;
};

const int UNKNOWN = INT_MAX;

bool HasNegativeCycle(const vector&lt;Edge&gt;&amp; edges, vector&lt;int&gt; distance)
{
    for(auto&amp; e : edges)
    {
        if(distance[e.src]==UNKNOWN)
            continue;
        if(distance[e.src]+e.weight&lt;distance[e.dst])
            return true;
    }
    return false;
}

vector&lt;int&gt; BellmanFord(vector&lt;Edge&gt; edges, int V)
{
    vector&lt;int&gt; distance(V+1, UNKNOWN);

    int s=V;
    for(int i=0; i&lt;V;i++)
    {
        edges.push_back(Edge{s,i,0});
    }
    distance[s]=0;

    for(int i=0; i&lt;V; i++)
    {
        for(auto&amp; e : edges)
        {
            if(distance[e.src]==UNKNOWN)
                continue;
            if(distance[e.dst]&gt;distance[e.src]+e.weight)
            {
                distance[e.dst]=distance[e.src]+e.weight;
            }
        }
    }
    if(HasNegativeCycle(edges,distance))
    {
        cout&lt;&lt;"음수 가중치 사이클 발견!"&lt;&lt;endl;
        return {};
    }
    return distance;
}
    
int GetMinDistance(vector&lt;int&gt;&amp; distance, vector&lt;bool&gt;&amp; visited)
{
    int minDistance = UNKNOWN;
    int minIndex = -1;

    for(int i=0; i&lt;distance.size(); i++)
    {
        if(!visited[i]&amp;&amp;distance[i]&lt;=minDistance)
        {
            minDistance=distance[i];
            minIndex=i;
        }
    }
    return minIndex;
} 


vector&lt;int&gt; Dijkstra(vector&lt;Edge&gt; edges, int V, int start)
{
    vector&lt;int&gt; distance(V,UNKNOWN);
    vector&lt;bool&gt; visited(V, false);
     
    distance[start]=0;

    for(int i=0; i&lt;V-1; i++)
    {
        int curr= GetMinDistance(distance, visited);
            
        visited[curr]=true;
        for(auto&amp; e :edges)
        {
            if(e.src !=curr)
                continue;
            if(visited[e.dst])
                continue;
            if(distance[curr]!=UNKNOWN&amp;&amp;distance[e.dst]&gt;distance[curr]+e.weight)
                distance[e.dst]=distance[curr]+e.weight;
        }
    }
    return distance;
}

void Johnson(vector&lt;Edge&gt; edges, int V)
{
    vector&lt;int&gt; h=BellmanFord(edges, V);
    if(h.empty())
        return;
    for(auto&amp; e : edges)
    {
        e.weight+=(h[e.src]-h[e.dst]);
    }
    vector&lt;vector&lt;int&gt;&gt; shortest(V);
    for(int i=0; i&lt;V; i++)
    {
        shortest[i]=Dijkstra(edges, V, i);
    }
    for(int i=0; i&lt;V; i++)
    {
        cout&lt;&lt;i&lt;&lt;":\n";

        for(int j=0; j&lt;V; j++)
        {
            if(shortest[i][j]!=UNKNOWN)
            {
                shortest[i][j] +=h[j]-h[i];
                cout&lt;&lt;"\t"&lt;&lt;j&lt;&lt;":"&lt;&lt;shortest[i][j]&lt;&lt;endl;
            }
        }
    }
}

int main()
{
    int V=5;
    vector&lt;Edge&gt; edges;

    vector&lt;vector&lt;int&gt;&gt; edge_map{{0,1,-7},{1,2,-2},{2,0,10},{0,3,-5},{0,4,2},{3,4,4}};

    for(auto&amp; e : edge_map)
    {
        edges.emplace_back(Edge {e[0],e[1],e[2]});
    }
    Johnson(edges, V);
}
Run<br>그래프<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/cf7a1ad9-c25d-4ecc-ad0e-4bf30ac32a5e" referrerpolicy="no-referrer"><br>실행 결과<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/eb7d5252-5c53-4cc4-b819-330307c8ccba" referrerpolicy="no-referrer">]]></description><link>공부\알고리즘\그래프-알고리즘\존슨-알고리즘.html</link><guid isPermaLink="false">공부/알고리즘/그래프 알고리즘/존슨 알고리즘.md</guid><pubDate>Thu, 13 Mar 2025 07:18:32 GMT</pubDate><enclosure url="https://github.com/bloodmoon3929/Algorithm/assets/144004857/1cf6442e-0160-4bf3-9bac-bdbc6c6fb7f5" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://github.com/bloodmoon3929/Algorithm/assets/144004857/1cf6442e-0160-4bf3-9bac-bdbc6c6fb7f5&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[코사라주 알고리즘]]></title><description><![CDATA[ 
 <br><br>강한 연결요소는 부분 집합에 대하여 다른 집합으로 정보를 보낼수는 있지만, 받을수는 없는 구조를 말합니다. 아래의 그림을 토대로 이해하면 편할 것입니다.<br>강한 연결 요소<br><br>
<img alt="강한연결요소" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/32b3ebe0-fd61-4988-b4e8-3904c96312ad" referrerpolicy="no-referrer"><br><br>코사라주 알고리즘은 강한 연결 요소들을 판별해내는 알고리즘입니다. 알고리즘의 메커니즘은 우선 DFS(<a data-href="깊이 우선 탐색" href="공부\알고리즘\그래프-알고리즘\깊이-우선-탐색.html" class="internal-link" target="_self" rel="noopener nofollow">깊이 우선 탐색</a>)한 후 그래프의 방향을 기존에 가르치던 방향의 반대 바라보도록 만듭니다. 그 후 해당 그래프를 DFS를 하게 된다면, 강한 연결요소들이 구별될 것입니다.<br>
<br><br>
책에 나온 그래프로 예시를 보여드리겠습니다. 시작 정점은 0번 정점이라 가정하고, 정점의 번호가 적은 것을 선택한다 가정하겠습니다. <br><br>그래프<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/6f650f1e-3d85-4ce9-9c43-1a82e4531820" referrerpolicy="no-referrer"><br>방문 정점<br><br>종료 순서 스택<br><br>스택은 선입 후출 구조이므로 0번 정점부터 DFS를 실시 하겠습니다.<br>전치 그래프<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/c7768cc6-1d09-4068-b4c5-8181bbb7f901" referrerpolicy="no-referrer"><br>
<br><br>강한 연결 요소<br><br><br><br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;stack&gt;

using namespace std;

void FillStack(int node, vector&lt;bool&gt;&amp; visited, vector&lt;vector&lt;int&gt;&gt;&amp; adj, stack&lt;int&gt;&amp; stack)
{
    visited[node]=true;

    for(auto next : adj[node])
    {
        if(!visited[next])
        {
            FillStack(next, visited, adj, stack);
        }
    }
    stack.push(node);
}

vector&lt;vector&lt;int&gt;&gt; Transpose(int V, vector&lt;vector&lt;int&gt;&gt; adj)
{
    vector&lt;vector&lt;int&gt;&gt; transpose(V);

    for(int i=0; i&lt;V; i++)
    {
        for(auto next :adj[i])
        {
            transpose[next].push_back(i);
        }
    }
    return transpose;
}

void CollectConnectedComponents(int node, vector&lt;bool&gt;&amp; visited, vector&lt;vector&lt;int&gt;&gt;&amp; adj, vector&lt;int&gt;&amp; component)
{
    visited[node]=true;
    component.push_back(node);

    for(auto next : adj[node])
    {
        if(!visited[next])
        {
            CollectConnectedComponents(next, visited, adj, component);
        }
    }
}

vector&lt;vector&lt;int&gt;&gt; Kosaraju(int V, vector&lt;vector&lt;int&gt;&gt; adj)
{
    vector&lt;bool&gt; visited(V, false);
    stack&lt;int&gt; stack;

    for(int i=0; i&lt;V; i++)
    {
        if(!visited[i])
        {
            FillStack(i, visited, adj, stack);
        }
    }
    vector&lt;vector&lt;int&gt;&gt; transpose = Transpose(V, adj);
    fill(visited.begin(), visited.end(),false);
    vector&lt;vector&lt;int&gt;&gt; connectedComponents;

    while(!stack.empty())
    {
        int node= stack.top();
        stack.pop();

        if(!visited[node])
        {
            vector&lt;int&gt; component;

            CollectConnectedComponents(node, visited, transpose, component);
            connectedComponents.push_back(component);
        }
    }
    return connectedComponents;
}

int main()
{
    int V=9;
    vector&lt;vector&lt;int&gt;&gt; adj={{1,3},{2,4},{3,5},{7},{2},{4,6},{7,2},{8},{3}};

    vector&lt;vector&lt;int&gt;&gt; connectedComponents = Kosaraju(V, adj);
    cout&lt;&lt;"강한 연결 요소 개수 : "&lt;&lt;connectedComponents.size()&lt;&lt;endl;
    for(int i=0; i &lt; connectedComponents.size(); i++)
    {
        cout&lt;&lt;"["&lt;&lt;i+1&lt;&lt;"]";
        for(auto node : connectedComponents[i])
            cout&lt;&lt;node&lt;&lt;" ";
        cout&lt;&lt;endl;
    }
}
Run<br>그래프<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/6f650f1e-3d85-4ce9-9c43-1a82e4531820" referrerpolicy="no-referrer"><br>방향 그래프가 지시하는 것<br><br><br>실행 결과<br><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/3e36f4a8-5535-4f54-a4e9-2a0b7b929b41" referrerpolicy="no-referrer">]]></description><link>공부\알고리즘\그래프-알고리즘\코사라주-알고리즘.html</link><guid isPermaLink="false">공부/알고리즘/그래프 알고리즘/코사라주 알고리즘.md</guid><pubDate>Thu, 13 Mar 2025 07:21:41 GMT</pubDate><enclosure url="https://github.com/bloodmoon3929/Algorithm/assets/144004857/32b3ebe0-fd61-4988-b4e8-3904c96312ad" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://github.com/bloodmoon3929/Algorithm/assets/144004857/32b3ebe0-fd61-4988-b4e8-3904c96312ad&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[병합 정렬]]></title><description><![CDATA[ 
 <br>병합 정렬은 전체 집합을 하나의 원소만을 가질때까지 계속하여 부분 집합으로 나눈뒤 올림차순 혹은 내림차순인 상태를 유지하며 합치는 방식입니다.<br>
<br><br><br>
다음은 병합 정렬의 코드입니다.<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
uaing namespace std;

template&lt;typename T&gt;
vector&lt;T&gt; merge(vector&lt;T&gt;&amp; arr1, vector&lt;T&gt;&amp; arr2)
{
	vector&lt;T&gt; merged;

	auto iter1 = arr1.begin();
	auto iter2 = arr2.begin();

	while (iter1 != arr1.end()&amp;&amp;iter2 != arr2.end())
	{
		if (*iter1 &lt; *iter2)
		{
			merged.emplace_back(*iter1);
			iter1++;
		}
		else
		{
			merged.emplace_back(*iter2);
			iter2++;
		}

	}
	if (iter1 != arr1.end())
	{
		for (; iter1 != arr1.end(); iter1++)
			merged.emplace_back(*iter1);
	}
	else
	{
		for (; iter2 != arr2.end(); iter2++)
			merged.emplace_back(*iter2);
	}
	return merged;
}

template&lt;typename T&gt;
vector&lt;T&gt; merge_sort(vector&lt;T&gt; arr)
{
	if (arr.size() &gt; 1)
	{
		auto mid = size_t(arr.size() / 2);
		auto left_half = merge_sort&lt;T&gt;(vector&lt;T&gt;(arr.begin(), arr.begin() + mid));
		auto right_half = merge_sort&lt;T&gt;(vector&lt;T&gt;(arr.begin() + mid, arr.end()));

		return merge&lt;T&gt;(left_half, right_half);
	}
	return arr;
}

template&lt;typename T&gt;
void print_vector(std::vector&lt;T&gt; arr)
{
	for (auto i : arr)
		cout &lt;&lt; i &lt;&lt; " ";
	cout &lt;&lt; endl;
}

void run_merge_sort_test()
{
	vector&lt;int&gt;	S1{ 45, 1, 3, 1, 2, 3, 45, 5, 1, 2, 44, 5, 7 };
	vector&lt;float&gt;	S2{ 45.6f, 1.0f, 3.8f, 1.01f, 2.2f, 3.9f, 45.3f, 5.5f, 1.0f, 2.0f, 44.0f, 5.0f, 7.0f };
	vector&lt;double&gt;	S3{ 45.6, 1.0, 3.8, 1.01, 2.2, 3.9, 45.3, 5.5, 1.0, 2.0, 44.0, 5.0, 7.0 };
	vector&lt;char&gt;	S4{ 'b', 'z', 'a', 'e', 'f', 't', 'q', 'u', 'y'};

	cout &lt;&lt; "정렬되지 않은 입력 벡터:" &lt;&lt; endl;
	print_vector&lt;int&gt;(S1);
	print_vector&lt;float&gt;(S2);
	print_vector&lt;double&gt;(S3);
	print_vector&lt;char&gt;(S4);
	cout &lt;&lt; endl;

	auto sorted_S1 = merge_sort&lt;int&gt;(S1);
	auto sorted_S2 = merge_sort&lt;float&gt;(S2);
	auto sorted_S3 = merge_sort&lt;double&gt;(S3);
	auto sorted_S4 = merge_sort&lt;char&gt;(S4);

	cout &lt;&lt; "병렬 정합에 의해 정렬된 벡터:" &lt;&lt; endl;
	print_vector&lt;int&gt;(sorted_S1);
	print_vector&lt;float&gt;(sorted_S2);
	print_vector&lt;double&gt;(sorted_S3);
	print_vector&lt;char&gt;(sorted_S4);
	cout &lt;&lt; endl;
}

int main()
{
	run_merge_sort_test();
	return 0;
}
Run<br>각각의 함수에 대한 간단한 설명을 하겠습니다.<br><br>
1. vector&lt;T&gt; merge(vector&lt;T&gt;&amp; arr1, vector&lt;T&gt;&amp; arr2)<br><br>
해당 함수는 우선 전달인자로 두 배열을 받습니다. 그 후 다음의 절차를 진행합니다.<br>
<br>배열의 첫 원소 값을 비교하여 원소의 값이 작은 것을 merge 배열에 추가합니다.
<br>1번 과정을 두 배열중 하나의 배열의 모든 원소 값을 merge배열에 추가할때까지 반복합니다.
<br>만일 두 배열중 하나의 배열의 모든 원소값이 merge배열에 추가 되었다면 나머지 배열을 merge배열에 추가합니다.
<br>그 후 함수의 반환형인 vector함수의 형태로 merge배열을 반환합니다.<br><br><br>
2. vector&lt;T&gt; merge_sort(vector&lt;T&gt; arr)<br><br>
해당 함수는 배열의 원소가 1개를 가질때까지 배열의 가운데를 기준으로 쪼개서 배열이 한 개의 원소만을 가질때까지 분해한 후, 부분 집합들을 merge함수를 통해 정렬상태를 유지한 상태로 병합합니다.<br><br><br>
3. void print_vector(vector&lt;T&gt; arr)<br><br>
해당 함수는 배열의 시작 원소부터 마지막 원소까지 순서대로 출력하는 함수입니다.<br><br><br>
4. void run_merge_sort_test()<br><br>
해당 함수는 여러 정렬 알고리즘의 필수 3요소 중 모든 타입에 대해 동작하는지 알아보기 위해, 다양한 타입의 vector 배열을 merge_sort 함수를 사용해서 정렬하는 것을 시연하기 위해 만들어진 함수입니다.<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>이 배열을 브루트 포스로 풀게 된다면, 시간 복잡도는 이지만, 병합 정렬로 풀게 된다면 시간 복잡도는 이 될 것이다.]]></description><link>공부\알고리즘\정렬\분할정복\병합-정렬.html</link><guid isPermaLink="false">공부/알고리즘/정렬/분할정복/병합 정렬.md</guid><pubDate>Wed, 12 Mar 2025 06:55:30 GMT</pubDate></item><item><title><![CDATA[분할 정복]]></title><description><![CDATA[ 
 <br><br>분할 정복 접근방법은 크게 3단계로 나눌수 있습니다.<br><br>
<br>분할 : 주어진 문제를 모두 동일하게 해결할 수 있는 세부 문제로 나눕니다.
<br>정복 : 나누어진 세부 문제들의 해답을 구합니다.
<br>결합 : 해답이 구해진 세부 문제들을 결합하여 전체문제의 해답을 구합니다.
<br><br>정렬 알고리즘 구현에 있어 필요한 3가지 요구사항이 있습니다.<br><br>
<br>모든 데이터 타입에 대해 동작해야 합니다.
<br>많은 양의 데이터를 처리할 수 있어야 합니다.
<br>점근적 시작 복잡도 측면이나 실제 동작시 빨라야 합니다.
<br>크게 3가지 정렬 알고리즘이 소개되었습니다.<br>
<br><a class="internal-link" data-href="#1-병합-정렬" href="about:blank#1-병합-정렬" target="_self" rel="noopener nofollow">병합 정렬</a>
<br><a class="internal-link" data-href="#2-퀵-정렬" href="about:blank#2-퀵-정렬" target="_self" rel="noopener nofollow">퀵 정렬</a>
<br><a class="internal-link" data-href="#3-선형-시간-선택" href="about:blank#3-선형-시간-선택" target="_self" rel="noopener nofollow">선형 시간 선택</a>
]]></description><link>공부\알고리즘\정렬\분할정복\분할-정복.html</link><guid isPermaLink="false">공부/알고리즘/정렬/분할정복/분할 정복.md</guid><pubDate>Thu, 13 Mar 2025 07:22:08 GMT</pubDate></item><item><title><![CDATA[선형 시간 선택]]></title><description><![CDATA[ 
 <br>선형 시간 선택은 전체 정렬에서 n번째로 작은 원소를 찾을 때 사용할 수 있습니다.<br>
<br>전체 집합을 정렬하고 n번째 원소를 찾고자 한다면 시간이 소모 되겠지만 선형 시간 선택 알고리즘을 사용하면 의 시간으로 원소를 구할수 있습니다.<br>
<br><br>
책을 기준으로<br>
<br>입력 버퍼를 5개의 원소를 가지는 부분 집합으로 나눕니다.
<br>각각의 부분 집합들을 정렬합니다.
<br>각각의 집합들에서 중앙값을 구하고, 중앙값들의 집합에서 또 중앙값을 찾습니다.
<br>찾은 중앙값을 기준으로 두개의 벡터로 나눕니다.
<br><br>
<br>

<br>나누어진 벡터 중 피벗보다 원소값이 작은 원소의 집합의 사이즈+1의 값이 n과 같다면 찾고자한 값을 찾은 것이고,<br>
<br>집합의 사이즈+1의 값이 n보다 작다면 피벗보다 큰 원소값으로 구성된 집합을 가지고 1번 과정을 반복합니다.
<br>집합의 사이즈+1의 값이 n보다 크다면 피벗보다 작은 원소값으로 구성된 집합을 가지고 1번 과정을 반복합니다.


<br>다음은 선형 시간 선택의 코드입니다.<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

template&lt;typename T&gt;
auto partition(typename vector&lt;T&gt;::iterator begin, typename vector&lt;T&gt;::iterator end)
{
    auto pivot_val=*begin;
    auto left_iter=begin+1;
    auto right_iter=end;
    while (true)
    {
        while (*left_iter&lt;=pivot_val&amp;&amp;distance(left_iter, right_iter)&gt;0)
           left_iter++;
        while (*right_iter&gt;pivot_val&amp;&amp;distance(left_iter, right_iter)&gt;0)
           right_iter--;
        if(right_iter==left_iter)
            break;
        else
            iter_swap(left_iter, right_iter);
        
    }
    if(pivot_val&gt;*right_iter)
        iter_swap(begin, right_iter);

    return right_iter;
}

template&lt;typename T&gt;
void quick_sort(typename vector&lt;T&gt;::iterator begin, typename std::vector&lt;T&gt;::iterator end)
{
    if(distance(begin, end)&gt;=1)
    {
        auto partition_iter = partition&lt;T&gt;(begin, end);
        quick_sort&lt;T&gt;(begin, partition_iter-1);
        quick_sort&lt;T&gt;(partition_iter,end);
    }
}

template&lt;typename T&gt;
auto find_median(typename vector&lt;T&gt;::iterator begin, typename vector&lt;T&gt;::iterator last)
{
    quick_sort&lt;T&gt;(begin, last);
    return begin+(distance(begin, last)/2);
}

template&lt;typename T&gt;
auto partition_using_given_pivot(typename vector&lt;T&gt;::iterator begin, typename vector&lt;T&gt;::iterator end, typename vector&lt;T&gt;::iterator pivot)
{
    auto left_iter=begin;
    auto right_iter=end;
    while (true)
    {
        while(*left_iter&lt;*pivot&amp;&amp;left_iter!=right_iter)
            left_iter++;
        while(*right_iter&gt;=*pivot&amp;&amp;left_iter!=right_iter)
            right_iter--;
        if(left_iter==right_iter)
            break;
        else
            iter_swap(left_iter, right_iter);
    }
    if(*pivot&gt;*right_iter)
        iter_swap(pivot, right_iter);
    return right_iter;
}

template&lt;typename T&gt;
typename vector&lt;T&gt;::iterator linear_time_select(typename vector&lt;T&gt;::iterator begin, typename vector&lt;T&gt;::iterator last, size_t i)
{
   auto size = distance(begin, last);
   if(size&gt;0&amp;&amp;i&lt;size)
   {
       auto num_Vi = (size+4)/5;
       size_t j =0;

       vector&lt;T&gt; M;
       for(;j&lt;size/5;j++)
       {
           auto b=begin+(j*5);
           auto l=begin+(j*5)+5;
           M.push_back(*find_median&lt;T&gt;(b, l));
       }
       if(j*5&lt;size)
       {
           auto b=begin+(j*5);
           auto l=begin+(j*5)+(size%5);
           M.push_back(*find_median&lt;T&gt;(b, l));
       }
       auto median_of_medians = (M.size()==1)?M.begin():linear_time_select&lt;T&gt;(M.begin(), M.end()-1, M.size()/2);
       auto partition_iter = partition_using_given_pivot&lt;T&gt;(begin, last, median_of_medians);
       auto k = distance(begin, partition_iter)+1;
       if(i==k)
           return partition_iter;
       else if(i&lt;k)
           return linear_time_select&lt;T&gt;(begin, partition_iter-1, i);
       else
           return linear_time_select&lt;T&gt;(partition_iter+1, last, i-k);
    }
    else
    {
       return begin;
    }
}

template&lt;typename T&gt;
vector&lt;T&gt; merge(vector&lt;T&gt;&amp; arr1, vector&lt;T&gt;&amp; arr2)
{
    std::vector&lt;T&gt; merged;
    auto iter1 = arr1.begin();
    auto iter2 = arr2.begin();
    while(iter1!=arr1.end()&amp;&amp;iter2!=arr2.end())
    {
        if(*iter1&lt;*iter2)
        {
            merged.emplace_back(*iter1);
            iter1++;
        }
        else
        {
            merged.emplace_back(*iter2);
            iter2++;
        }
    }
    if(iter1!=arr1.end())
    {
        for(;iter1!=arr1.end();iter1++)
            merged.emplace_back(*iter1);
    }
    else
    {
        for(;iter2!=arr2.end();iter2++)
            merged.emplace_back(*iter2);
    }
    return merged;
}

template&lt;typename T&gt;
vector&lt;T&gt; merge_sort(vector&lt;T&gt; arr)
{
    if(arr.size()&gt;1)
    {
        auto mid=size_t(arr.size()/2);
        auto left_half = merge_sort(vector&lt;T&gt;(arr.begin(), arr.begin()+mid));
        auto right_half = merge_sort(vector&lt;T&gt;(arr.begin()+mid, arr.end()));

        return merge(left_half, right_half);
    }
    return arr;
}

template&lt;typename T&gt;
void print_vector(vector&lt;T&gt; arr)
{
	for (auto i : arr)
		cout &lt;&lt; i &lt;&lt; " ";
	cout &lt;&lt; endl;
}

void run_linear_select_test()
{
    vector&lt;int&gt; S1{45, 1, 3, 1,2,3,45,5,1,2,44,5,7};
    cout&lt;&lt;"입력 벡터: "&lt;&lt;endl;
    print_vector&lt;int&gt;(S1);
    cout&lt;&lt;"정렬된 벡터: "&lt;&lt;endl;
    print_vector&lt;int&gt;(merge_sort&lt;int&gt;(S1));
    cout&lt;&lt;"3번째 원소"&lt;&lt;*linear_time_select&lt;int&gt;(S1.begin(), S1.end()-1, 3)&lt;&lt;endl;
    cout&lt;&lt;"5번째 원소"&lt;&lt;*linear_time_select&lt;int&gt;(S1.begin(), S1.end()-1, 5)&lt;&lt;endl;
    cout&lt;&lt;"11번째 원소"&lt;&lt;*linear_time_select&lt;int&gt;(S1.begin(), S1.end()-1, 11)&lt;&lt;endl;
}

int main()
{
    run_linear_select_test();
    return 0;
}
Run<br>각각의 함수에 대한 간단한 설명을 하겠습니다.<br><br>
1. auto find_medianiterator begin, typename vector&lt;T&gt;::iterator last<br><br>
해당 함수는 배열을 정렬한 후 배열의 중간 원소의 주소값을 반환하는 함수입니다.<br>
<br><br>2. auto partition_using_given_pivotiterator begin, typename vector&lt;T&gt;::iterator end, typename vector&lt;T&gt;::iterator pivot<br><br>
해당 함수는 피벗을 기준으로 작은 값은 왼쪽으로, 큰 값은 오른쪽으로 옮기는, 이미 퀵 정렬에서 비슷한 개념을 한번 사용했었음, 함수입니다. 다만 배열 하나를 분할 하는 것이 아닌 전체 배열에서 중앙값을 찾은 후 그것을 피벗 삼아 분리하기에 전달인자가 한개 더 있습니다.<br>
<br><br>3. typename vector&lt;T&gt;::iterator linear_time_selectiterator begin, typename vector&lt;T&gt;::iterator last, size_t i<br><br>
해당 함수는 배열을 5개를 기준으로 나눈후 그 중앙값을 벡터 M에 저장한후 중간값의 중간 값을 찾고, 이를 피벗 삼아 분할하여, 피벗이 n번째 원소가 아니라면<br>
<br>피벗이 n보다 크다면 피벗보다 작은 원소들의 집합을 재귀 시키고,
<br>피벗이 n보다 작다면 피벗보다 큰 원소들의 집합을 재귀시킵니다.
<br>피벗과 n가 같을 때까지 과정을 반복합니다.
]]></description><link>공부\알고리즘\정렬\분할정복\선형-시간-선택.html</link><guid isPermaLink="false">공부/알고리즘/정렬/분할정복/선형 시간 선택.md</guid><pubDate>Wed, 12 Mar 2025 06:56:40 GMT</pubDate></item><item><title><![CDATA[퀵 정렬]]></title><description><![CDATA[ 
 <br>퀵 정렬은 임의의 원소를 피벗으로 하여, 피벗과 비교하여 작은 값이 모인 집합과 큰 값이 모인 집합 두개로 나눕니다. 그 후 만들어진 두 집합 역시 동일한 과정을 거쳐 원소를 하나만 가질때까지 반복합니다.<br>
퀵 정렬은 최악의 경우 의 시간 복잡도를 가지게 되는 데, 그럼에도 병합정렬이 아닌 퀵 정렬을 사용하는 이유는 평균 시간 복잡도는 으로 병합 정렬보다 빠르기 때문입니다. 또한 추가적인 메모리를 필요로하지 않고, 입력 배열 자체를 정렬하는 제자리 정렬 알고리즘입니다.<br>
<br><br><br>
다음은 퀵 정렬의 코드입니다.<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
using namespace std;

template&lt;typename T&gt;
auto partition(typename vector&lt;T&gt;::iterator begin, typename vector&lt;T&gt;::iterator end)
{
    auto pivot_val=*begin;
    auto left_iter=begin+1;
    auto right_iter=end;
    while (true)
    {
        while (*left_iter&lt;=pivot_val&amp;&amp;std::distance(left_iter, right_iter)&gt;0)
           left_iter++;
        while (*right_iter&gt;pivot_val&amp;&amp;std::distance(left_iter, right_iter)&gt;0)
           right_iter--;
        if(right_iter==left_iter)
            break;
        else
            iter_swap(left_iter, right_iter);
        
    }
    if(pivot_val&gt;*right_iter)
        iter_swap(begin, right_iter);

    return right_iter;
}

template&lt;typename T&gt;
void quick_sort(typename vector&lt;T&gt;::iterator begin, typename vector&lt;T&gt;::iterator end)
{
    if(distance(begin, end)&gt;=1)
    {
        auto partition_iter = partition&lt;T&gt;(begin, end);
        quick_sort&lt;T&gt;(begin, partition_iter-1);
        quick_sort&lt;T&gt;(partition_iter,end);
    }
}

template&lt;typename T&gt;
void print_vector(vector&lt;T&gt; arr)
{
	for (auto i : arr)
		cout &lt;&lt; i &lt;&lt; " ";
	cout &lt;&lt; endl;
}

void run_quick_sort_test()
{
	vector&lt;int&gt;	S1{ 45, 1, 3, 1, 2, 3, 45, 5, 1, 2, 44, 5, 7 };
	vector&lt;float&gt;	S2{ 45.6f, 1.0f, 3.8f, 1.01f, 2.2f, 3.9f, 45.3f, 5.5f, 1.0f, 2.0f, 44.0f, 5.0f, 7.0f };
	vector&lt;double&gt;	S3{ 45.6, 1.0, 3.8, 1.01, 2.2, 3.9, 45.3, 5.5, 1.0, 2.0, 44.0, 5.0, 7.0 };
	vector&lt;char&gt;	S4{ 'b', 'z', 'a', 'e', 'f', 't', 'q', 'u', 'y'};

	cout &lt;&lt; "정렬되지 않은 입력 벡터:" &lt;&lt; endl;
	print_vector&lt;int&gt;(S1);
	print_vector&lt;float&gt;(S2);
	print_vector&lt;double&gt;(S3);
	print_vector&lt;char&gt;(S4);
	cout &lt;&lt; endl;

	quick_sort&lt;int&gt;(S1.begin(),S1.end()-1);
	quick_sort&lt;float&gt;(S2.begin(),S2.end()-1);
	quick_sort&lt;double&gt;(S3.begin(),S3.end()-1);
	quick_sort&lt;char&gt;(S4.begin(),S4.end()-1);

	cout &lt;&lt; "퀵 정합에 의해 정렬된 벡터:" &lt;&lt; endl;
	print_vector&lt;int&gt;(S1);
	print_vector&lt;float&gt;(S2);
	print_vector&lt;double&gt;(S3);
	print_vector&lt;char&gt;(S4);
	cout &lt;&lt; endl;
}

int main()
{
	run_quick_sort_test();
	return 0;
}
Run<br>각각의 함수에 대한 간단한 설명을 하겠습니다.<br><br>
1. auto partitioniterator begin, typename vector&lt;T&gt;::iterator end<br><br>
해당 함수는 전달인자로 배열의 시작 주소와 마지막 주소를 받습니다. 그 후 첫 번째 주소에 저장된 원소를 피벗으로 두고, 피벗을 기준으로 작은 값은 왼쪽, 큰 값은 오른쪽에 배치하고 반환 값으로는 피벗보다 큰 원소의 주소를 반환합니다.<br>
<br><br>2. void quick_sortiterator begin, typename vector&lt;T&gt;::iterator end<br><br>
해당 함수는 partition함수를 사용하여 얻은 원소를 기준으로 배열을 두개로 나누는 과정을 배열의 원소가 하나가 될 때까지 반복합니다.<br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
위에서 보듯 운이 좋지않다면, 단 하나의 값만을 정렬하는 좋지 못한 모습도 보인다.<br>
<br>이 경우(최악의 경우)에는 시간복잡도는 이 될 것입니다.<br>]]></description><link>공부\알고리즘\정렬\분할정복\퀵-정렬.html</link><guid isPermaLink="false">공부/알고리즘/정렬/분할정복/퀵 정렬.md</guid><pubDate>Thu, 13 Mar 2025 07:22:30 GMT</pubDate></item><item><title><![CDATA[선형 검색]]></title><description><![CDATA[ 
 <br>선형 검색의 경우 정렬되어 있지 않더라도 문제없이 작동합니다. 하지만 이는 정렬되어<br>
있다는 이점을 살리지 못한 검색 방법이며, 효율적이지 않습니다.<br><br><br>bool linear_search(int N, vector&lt;int&gt;&amp; sequence)
{
    for(auto i : sequence)
    {
        if(i==N)
            return true;
    }
    return false;
}
Run<br><br>
해당 코드는 N이라는 원소가 시퀀스에 포함되어 있는지 여부를 판단하는 코드입니다.<br>
선형 검색은 시쿼스의 시작원소 부터 마지막 원소까지 순차적으로 입력된 원소 N과 비교하여 같은지 여부를 판단합니다. 이 경우 시작 복잡도는 O(N)입니다.
<br>]]></description><link>공부\알고리즘\정렬\선형-검색.html</link><guid isPermaLink="false">공부/알고리즘/정렬/선형 검색.md</guid><pubDate>Wed, 12 Mar 2025 06:52:25 GMT</pubDate></item><item><title><![CDATA[이진 검색]]></title><description><![CDATA[ 
 <br>이진 검색은 정렬된 시퀀스에서만 사용할 수 있지만, 시간 복잡도는 선형 검색보다 효율적입니다.<br><br><br>이진 검색의 알고리즘은 다음과 같습니다.<br>
<br>시퀀스의 범위를 측정합니다.
<br>시퀀스의 가운데 원소와 찾고자 하는 값을 비교합니다. (만일 두 원소가 같다면 true를 반환)
<br>가운데 원소와 찾고자 하는 값을 비교하여

<br>가운데 원소보다 값이 작다면, 가운데 원소부터 그 이상의 원소를 제거합니다.
<br>반대로 작다면, 가운데 원소부터 그 이하의 원소를 제거합니다.


<br>범위를 다시 측정하여 측정한 범위가 1 초과이면 2 번쨰 과정을 반복합니다.(만일 이 과정을 수행할 수 없다면, 시퀀스에는 찾고자 한 원소가 존재하지 않는 것이기에 false를 반환합니다.)<br>
<br>다음은 이진 검색의 C++ 코드입니다.<br>bool binary_search(int N, vector&lt;int&gt;&amp; S)
{
    auto first = S.begin();
    auto last = S.end();

    while(true)
    {
        auto lenth = distance(first, last);
        auto middle_index = first+floor(lenth/2);
        auto middle = *(middle_index);

        if(middle==N)
            return true;
        if(middle&gt;N)
            advance(last, middle_index);
        else
            advance(first, middle_index);
        
        if(lenth==1)
            return false;
    }
}
Run<br><br>
이제 두 가지 경우의 소모 시간을 비교해보겠습니다.<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;chrono&gt;
#include &lt;random&gt;
#include &lt;algorithm&gt;
using namespace std;

bool linear_search(int N, vector&lt;int&gt;&amp; S)
{
    for(auto i : S)
    {
        if(i==N)
            return true;
    }
    return false;
}

bool binary_search(int N, vector&lt;int&gt;&amp; S)
{
    auto first = S.begin();
    auto last = S.end();

    while(true)
    {
        auto range_length = distance(first, last);
        auto middle_index = range_length / 2;
        auto middle = *(first + middle_index);

        if(middle == N)
            return true;
        else if(middle &gt; N)
            advance(last, -middle_index);
        if(middle &lt; N)
            advance(first, middle_index);

        if(range_length == 1)
            return false;
    }
}


void search_test(int size, int N)
{
    vector&lt;int&gt; S;
    random_device rd;
    mt19937 rand(rd());

    uniform_int_distribution&lt;mt19937::result_type&gt; uniform_dist(1,size);

    for(auto i =0; i&lt;size;i++)
        S.push_back(uniform_dist(rand));

    sort(S.begin(),S.end());

    chrono::steady_clock::time_point begin = chrono::steady_clock::now();
    bool search_result=binary_search(N,S);
    chrono::steady_clock::time_point end = chrono::steady_clock::now();
    auto diff = std::chrono::duration_cast&lt;chrono::microseconds&gt;(end-begin);
    cout&lt;&lt;"이진 검색 수행 시간:"&lt;&lt;diff.count()&lt;&lt;endl;

    if(search_result)
        cout&lt;&lt;"이진 검색으로 원소를 찾았습니다."&lt;&lt;endl;
    else
        cout&lt;&lt;"이진 검색으로 원소를 찾지 못했습니다."&lt;&lt;endl;

    chrono::steady_clock::time_point begin1 = chrono::steady_clock::now();
    bool search_result1=linear_search(N,S);
    chrono::steady_clock::time_point end1 = chrono::steady_clock::now();
    auto diff1 = chrono::duration_cast&lt;chrono::microseconds&gt;(end1-begin1);
    cout&lt;&lt;"선형 검색 수행 시간:"&lt;&lt;diff1.count()&lt;&lt;endl;

    if(search_result1)
        cout&lt;&lt;"선형 검색으로 원소를 찾았습니다."&lt;&lt;endl;
    else
        cout&lt;&lt;"선형 검색으로 원소를 찾지 못했습니다."&lt;&lt;endl;
    cout&lt;&lt;"-----------------------------------------"&lt;&lt;endl;
}

int main()
{
    search_test(100000, 36543);
    search_test(1000000, 36543);
    search_test(10000000, 36543);
    
    return 0;
}
Run<br>이진 검색의 수행시간은 0에 수렴하지만, 선형 검색의 경우 범위가 늘어남에 따라서 시간도 비례해서 늘어나는 모습을 볼 수 있다.<br>sort<br><br>
C++ 표준 라이브러리에서 제공하는 정렬 알고리즘이며, 임의 접근 반복자의 범위내의 요소들을 정렬합니다. 기본적으로는 올림차순이나 원한다면 내림차순도 가능합니다.<br>
<br><br><br>
함수의 기본형은 다음과 같습니다.<br>template&lt;class RandomIt&gt;
void sort(RandomIt first, RandomIt last);

template&lt;class RandomIt, class Compare&gt;
void sort(RandomIt first, RandomIt last, Compare comp);
Run<br>여기서 comp는 비교함수이고, 그 값에 따라 오름차순과 내림차순으로 나눠집니다. 간단한 예제를 보겠습니다.<br>std::sort(numbers.begin(), numbers.end(), [](int a, int b) {return a &gt; b;});
Run<br>이 경우 비교함수의 첫 번째 인자가 두 번째 인자보다 크기에 sort함수의 3번째 전달인자 값이 true가 되어 내림차순이 됩니다. 하지만 직접적으로 true 값을 전달인자 값으로 주어서는 안됩니다.<br>#include &lt;chrono&gt;<br><br>
이 헤더파일은 시간을 다루기 위해 사용하는 헤더파일입니다. 포함되어 있는 클래스는 다음과 같습니다.<br>chrono::duration
chrono::time_point
chrono::system_clock
chrono::high_resolution_clock
chrono::steady_clock
Run<br>
<br>
chrono::duration는 주로 chrono::duration&lt;Rep, Period&gt;형식으로 사용되며<br><br>
Rep은 자료형, Period는 시간의 간격의 단위를 나타낸다.<br>

<br>
chrono::time_point는 특정 시간을 나타냅니다. 주로 chrono::time_point&lt;Clock, Duration&gt;형태로 사용하며<br><br>
Clock은 측정하는 시계의 자료형을, Duration는 시각을 나타내는 시계의 자료형을 나타냅니다. 

<br>
chrono::system_clock는 현제 시간을 내타내며, 다음처럼 사용합니다. chrono::time_point&lt;chrono::system_clock&gt;

<br>
chrono::high_resolution_clock는 고해상도의 시간을 측정하는데 사용되며, 다음과 같이 사용합니다.<br>
chrono::time_point&lt;chrono::high_resolution_clock&gt;

<br>
std::chrono::steady_clock는 위의 클래스가 고해상도라면, 이 친구는 안정적인 속성을 지닌 시계이며 다음과 같이 사용합니다.<br>
chrono::time_point&lt;chrono::steady_clock&gt;

<br>#include &lt;random&gt;<br><br>
<br><br>
이 헤더파일은 난수를 생성하기 위해 사용되는 헤더파일이며, 포함된 클래스는 다음과 같습니다.<br>random_device
default_random_engine
uniform_int_distribution
uniform_real_distribution
normal_distribution
bernoulli_distribution
mt19937 rand(rd())
Run<br>
<br>random_device는 하드웨어 기반의 난수 생성 장치에 접근할 수 있는 인터페이스를 제공하는 클래스입니다.<br><br>
반환형은 random_device::result_type이고, result_type은 일반적으로 부호가 없는 정수 타입입니다.
<br>default_random_engine는 난수 생성을 담당하는 클래스입니다<br><br>
반환형은 일반적으로 부호가 없는 정수 입니다.
<br>uniform_int_distribution는 균일 분포에서 정수를 생성하는데 사용됩니다.<br><br>
반환형은 템플릿에 따라 다르지만 일반적으로 정수입니다.
<br>uniform_real_distribution는 균일 분포에서 실수를 생성하는데 사용됩니다.<br><br>
반환형은 템플릿에 따라 다르지만 일반적으로 실수입니다.
<br>normal_distribution는 정규 분포에서 난수를 생성하는데 사용됩니다.<br><br>
반환형은 템플릿에 따라 다르지만 일반적으로 생성된 난수입니다.
<br>bernoulli_distribution는 베르누이 분포에서 난수를 생성하는데 사용됩니다.<br><br>
반환형은 템플릿에 따라 다르지만 일반적으로 bool입니다.
<br>mt19937 rand(rd())은  Mersenne Twister 알고리즘을 구현한 난수 생성 엔진 중 하나입니다. C에서의 srand과 유사하다고 생각하면 되겠습니다.
<br>#include &lt;algorithm&gt;<br><br>
이 헤더파일은 4장에서 다시 볼 것이기에 간단히만 알아보도록 하겠습니다.<br><br>#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;

int main() {
    std::vector&lt;int&gt; source = {1, 2, 3, 4, 5, 6};
    std::vector&lt;int&gt; true_values;
    std::vector&lt;int&gt; false_values;

    auto partition_result = std::partition_copy(
        source.begin(), source.end(),
        std::back_inserter(true_values),
        std::back_inserter(false_values),
        [](int x) { return x % 2 == 0; }
    );
    return 0;
}
Run<br>이 결과 반환된 값은 다음과 같을 것 입니다.<br><br>
true_values: {2, 4, 6}, false_values: {1, 3, 5}]]></description><link>공부\알고리즘\정렬\이진-검색.html</link><guid isPermaLink="false">공부/알고리즘/정렬/이진 검색.md</guid><pubDate>Thu, 13 Mar 2025 06:13:45 GMT</pubDate></item><item><title><![CDATA[동적 계획법]]></title><description><![CDATA[ 
 ]]></description><link>공부\알고리즘\동적-계획법.html</link><guid isPermaLink="false">공부/알고리즘/동적 계획법.md</guid><pubDate>Thu, 13 Mar 2025 07:05:42 GMT</pubDate></item><item><title><![CDATA[레퍼런스]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://github.com/ChangYeop-Yang/Study-DataStructure" target="_blank">https://github.com/ChangYeop-Yang/Study-DataStructure</a>]]></description><link>공부\알고리즘\레퍼런스.html</link><guid isPermaLink="false">공부/알고리즘/레퍼런스.md</guid><pubDate>Tue, 11 Mar 2025 09:58:47 GMT</pubDate></item><item><title><![CDATA[메모이제이션]]></title><description><![CDATA[ 
 <br><br>재귀 함수중 피보나치의 예제입니다.<br>그냥 재귀 함수로만 풀게 된다면, 층마다 2개의 노드가 생김으로 시간 복잡도는 O(2^n)일 것입니다.<br>하지만 자세히 살펴보면, 반복되는 연산이 존재합니다. 이것을 활용하는 것을 메모라이제이션 방식이라고 합니다.<br>간단한 예제를 봅시다:<br>vector&lt;int&gt; memo(n + 1, -1);
memo[0] = 0;
memo[1] = 1;

int fibo(int n, std::vector&lt;int&gt;&amp; memo) 
{
	if (memo[n] != -1)
	{
		return memo[n];
	}
	memo[n] = fibo(n - 1, memo) + fibo(n - 2, memo);
	return memo[n];
}
Run<br>vector memo:<br>메모라이제이션 방식을 사용하기 위한 변수<br>if (memo[n] != -1) :<br>이미 사용된 적 있는 노드일 경우 노드의 값을 반환<br>return memo[n]; :<br>만일 사용된 적 없을 경우, 연산을 진행하여 변수에 저장후 반환]]></description><link>공부\알고리즘\메모이제이션.html</link><guid isPermaLink="false">공부/알고리즘/메모이제이션.md</guid><pubDate>Wed, 12 Mar 2025 06:45:40 GMT</pubDate><enclosure url="lib\media\image03.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\image03.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[백트래킹]]></title><description><![CDATA[ 
 <br>퇴각검색(영어: backtracking, 한국어: 백트래킹)은 한정 조건을 가진 문제를 풀려는 전략이다. "퇴각검색(backtrack)"이란 용어는 1950년대의 미국 수학자 D. H. 레머가 지었다.<br>백트래킹은 모든 조합을 시도해서 문제의 해를 찾는다. 이것이 장점이 될 수 있는 이유는 백트래킹의 구현 방법들이 많은 부분 조합들을 배제하기 때문이다. 결국 풀이 시간이 단축된다.<br>주요 개념은 해를 얻을 때까지 모든 가능성을 시도한다는 점이다. 모든 가능성은 하나의 트리처럼 구성할 수 있으며, 가지 중에 해결책이 있다. 트리를 검사하기 위해 깊이 우선 탐색을 사용한다. 탐색 중에 오답을 만나면 이전 분기점으로 돌아간다. 시도해보지 않은 다른 해결 방법이 있으면 시도한다. 해결 방법이 더 없으면 더 이전의 분기점으로 돌아간다. 모든 트리의 노드를 검사해도 답을 못 찾을 경우, 이 문제의 해결책은 없는 것이다.<br>퇴각검색은 보통 재귀 함수로 구현된다. 재귀로 파생된 해결 방법은 하나 이상의 변수가 필요한데 , 이것은 현재 시점에서 적용할 수 있는 변수값들을 알고 있다. 퇴각검색은 깊이 우선 탐색과 대략 같으나 기억 공간은 덜 차지한다. 현재의 상태를 보관하고 바꾸는 동안만 차지한다. 탐색 속도를 높이기 위해, 재귀 호출을 하기 전에 시도할 값을 정하고 조건(전진 탐색의 경우)을 벗어난 값을 지우는 알고리즘을 적용할 수 있다. 아니면 그 값을 제외한 다른 값들을 탐색할 수도 있다.<br>배열 A에서 N개를 뽑는 예제(조합 문제)<br>vector&lt;bool&gt; check(N, false);
void recursion(int M, int count, int index)
{
	if(count==M)
	{
		//출력하거나 배열에 저장
		return;
	}

	for (int i = index; i &lt; N; i++)
	{
		if (!check[i])
		{
			check[i] = true;
			recursion(M, count + 1, i + 1);
			check[i] = false;
		}
	}
}
Run<br>M의 역할:<br>
선택 되어야 될 원소의 수를 의미함,<br>count의 역할:<br>
현재까지 선택한 원소의 수.<br>index의 역할:<br>
탐색을 시작할 위치<br>종료 조건:<br>
count가 M에 도달하면 원하는 개수의 원소를 선택한 것이므로 출력하거나 배열에 저장.<br>재귀 구조:<br>
아직 선택되지 않은 원소를 찾아(!check[i]), 해당 원소를 선택(check[i] = true)한 후 재귀적으로 다음 원소를 탐색.<br>재귀가 끝난 후 선택을 취소(check[i] = false)해 백트래킹을 수행.<br>만일 이 문제를 브루트 포스로 풀려 하였으면, 다중 for문으로 찾아야 하였으며, 중복되는 연산이 존재하여 시간복잡도가 증가하였을 것이며, N개의 for문을 겹쳐야 하는데, N이 주어지지 않는다면, 구현도 불가능 했을 것.<br>#include&lt;bits/stdc++.h&gt;
#define endl "\n"

using namespace std;

long long MINN=INT_MAX, MAXX=-INT_MAX;
int oper[4];
vector&lt;long long&gt; Q;

void rec(int index, long long curr);

int main()
{
    int N,M;
    cin&gt;&gt;N;
    
    for(int i=0; i&lt;N; i++)
    {
        cin&gt;&gt;M;
        Q.push_back(M);
    }

    cin&gt;&gt;oper[0]&gt;&gt;oper[1]&gt;&gt;oper[2]&gt;&gt;oper[3];

    rec(0,Q[0]);

    cout&lt;&lt;MAXX&lt;&lt;endl;
    cout&lt;&lt;MINN&lt;&lt;endl;
}

void rec(int index, long long curr)
{
    if(index==Q.size()-1)
    {
        MINN=min(MINN,curr);
        MAXX=max(MAXX,curr);
        
        return;
    }

    for(int i=0; i&lt;4; i++)
    {
        if(oper[i]&gt;0)
        {
            oper[i]--;
            
            if(i==0)
                rec(index+1, curr+Q[index+1]);
            else if(i==1)
                rec(index+1, curr-Q[index+1]);
            else if(i==2)
                rec(index+1, curr*Q[index+1]);
            else if(i==3)
                curr&lt;0?rec(index+1, -((-curr)/Q[index+1])):rec(index+1, curr/Q[index+1]);

            oper[i]++;
        }
    }
}
Run<br>재귀함수를 통하여 모든 경우를 테스트 하는 함수이다.<br>주로 최대 입력 가능한 횟수와 (여기서는 Q.size()-1)<br>현재 사용한 갯수를 나타내는 index변수가 같을 때까지 반복하는 것으로 구함<br>후위 감소 연산자와 후위 증가 연산자 사이에 재귀함수를 사용하는데 <br>그 전달인자의 index에 1더한 값을 재귀시켜 한 개의 자원을 소모한 것으로 생각하게 한다.]]></description><link>공부\알고리즘\백트래킹.html</link><guid isPermaLink="false">공부/알고리즘/백트래킹.md</guid><pubDate>Thu, 13 Mar 2025 05:30:33 GMT</pubDate></item><item><title><![CDATA[브루트 포스(Brute force)]]></title><description><![CDATA[ 
 <br><br>Brute : 무식한<br>
Force : 힘<br>
직역하면, 무식한 힘을 갖는 알고리즘이란 뜻으로, 가능한 모든 경우의 수를 모두 탐색하면서 결과를 도출한다.<br>
전체를 탐색한다는 의미에서 전체 탐색, 완전 탐색이라고도 한다.<br>
브루트포스 알고리즘은 대부분은 반복문과 조건문을 통하여 답을 도출한다.<br><br>
<br>알고리즘을 설계하고 구현하기 쉽다
<br>모든 경우의 수를 탐색하기 때문에 100% 정확성을 보장한다.
<br><br>
<br>메모리 효율면에서 매우 비효율적이다.
<br>알고리즘의 실행 시간이 매우 오래걸린다. (시간복잡도가 높다)
<br><br><br>
<br>솔루션이 잘 정의되어 있지 않는 문제라면, 브루트 포스를 사용한 솔루션이 올바른지의 여부를 확인할 수 없다.
<br><br>
<br>문제에서 고려해야할 솔루션의 수가 한정되어 있어야 한다. 고려해야할 솔루션의 수가 무한하거나 너무 크면 브루트포스 알고리즘은 효율적이지 않은 방법이다.
<br><br><br>
<br>선형 구조 : 순차 탐색
<br>비선형 구조 : 백트래킹, DFS, BFS
<br>비선형 구조는 추후 별도로 포스팅 하겠습니다.<br><br><br>
<br>주어진 문제를 선형 구조로 구조화 한다.
<br>구조화된 문제공간을 적절한 방법으로 해를 구성할 때까지 탐색한다.
<br>구성된 해를 정리한다.
<br><br><br><img alt="첨부파일/queue/Image.png" src="lib\media\image.png"><br>
위와 같은 자물쇠를 다들 본적 있으리라 생각한다.<br>
해당 비밀번호를 찾아보는 간단한 예제를 들어보려고 한다.<br>
비밀번호는 내가 입력하는 방식으로 했다.<br>import java.util.Scanner;

public class BruteForce {
    public static void main(String[] args) {
        Scanner sc=new Scanner(System.in);

        int a=sc.nextInt();
        int b=sc.nextInt();
        int c=sc.nextInt();
        int d=sc.nextInt();

        for (int i=0;i&lt;10;i++){
            for (int j=0;j&lt;10;j++){
                for (int k=0;k&lt;10;k++){
                    for (int l=0;l&lt;10;l++){
                        if (i==a&amp;&amp;j==b&amp;&amp;c==k&amp;&amp;d==l){
                            System.out.println("비밀번호는 "+i+j+k+l);
                        }
                    }
                }
            }
        }
    }
}
<br><img alt="첨부파일/queue/Image 1.png" src="lib\media\image-1.png"><br>0000부터 9999까지 4자리 수를 모두 탐색해서 비밀번호를 찾았다.<br><br>
결론 : 값을 무조건 찾긴 하지만 시간이 오래 걸리므로 적절하게 사용하자.
]]></description><link>공부\알고리즘\브루트-포스(brute-force).html</link><guid isPermaLink="false">공부/알고리즘/브루트 포스(Brute force).md</guid><pubDate>Thu, 13 Mar 2025 07:27:03 GMT</pubDate><enclosure url="lib\media\image.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\image.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[에라토스네스의 체]]></title><description><![CDATA[ 
 <br><br>수학에서 에라토스테네스의 체는 소수를 찾는 방법이다. 고대 그리스 수학자 에라토스테네스가 발견하였다.<br>
<img alt="Eratosthenes.gif" src="lib\media\eratosthenes.gif"><br>
<br>2부터 소수를 구하고자 하는 구간의 모든 수를 나열한다. 그림에서 회색 사각형으로 두른 수들이 여기에 해당한다.
<br>2는 소수이므로 오른쪽에 2를 쓴다. (빨간색)
<br>자기 자신을 제외한 2의 배수를 모두 지운다.
<br>남아있는 수 가운데 3은 소수이므로 오른쪽에 3을 쓴다. (초록색)
<br>자기 자신을 제외한 3의 배수를 모두 지운다.
<br>남아있는 수 가운데 5는 소수이므로 오른쪽에 5를 쓴다. (파란색)
<br>자기 자신을 제외한 5의 배수를 모두 지운다.
<br>남아있는 수 가운데 7은 소수이므로 오른쪽에 7을 쓴다. (노란색)
<br>자기 자신을 제외한 7의 배수를 모두 지운다.
<br>위의 과정을 반복하면 구하는 구간의 모든 소수가 남는다.
<br>void SoE(const int n, const int m) 
{
    int pn = 0; // 소수의 개수
    vector&lt;int&gt;	prime; // 소수 저장
    vector&lt;bool&gt; check = vector&lt;bool&gt;(n + 1, false); // 소수 확인

	for (long long ii = 2; ii &lt;= n; ii++) 
    {
		if (check.at(ii) == false) 
        {
			pn++;
			prime.push_back(ii);

			for (long long jj = ii * ii; jj &lt;= n; jj += ii) 
				check[jj] = true;
		}
	}
}
Run<br>구현<br>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;cmath&gt;

using namespace std;

int main()
{
    int N,limit;
    cin&gt;&gt;N;
    vector&lt;bool&gt; arr(N+1);
    fill(arr.begin(),arr.end(),true);
    
    limit=sqrt(N);
    for(int i=2; i&lt;limit+1; i++)
    {
        if(arr[i]==true)
        {
            for(int j=i*i; j&lt;N+1; j+=i)
            {
                arr[j]=false;
            }
        }
    }
    for(int i=2; i&lt;N+1; i++)
    {
        if(arr[i]==true)
        {
            cout&lt;&lt;i&lt;&lt;", ";
        }
    }

    return 0;
}
Run<br>limit가 인 이유<br><br>
N이 100이라고 가정했을시, 100의 루트인 10의 배수에 100이 있기에 그 이상의 값은 확인하지 않아도 되기 때문]]></description><link>공부\알고리즘\에라토스네스의-체.html</link><guid isPermaLink="false">공부/알고리즘/에라토스네스의 체.md</guid><pubDate>Thu, 13 Mar 2025 05:29:37 GMT</pubDate><enclosure url="lib\media\eratosthenes.gif" length="0" type="image/gif"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\eratosthenes.gif&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[최대공약수]]></title><description><![CDATA[ 
 <br>수론에서, 정수들의 공약수(公約數, 영어: common divisor)는 동시에 그들 모두의 약수인 정수다. 적어도 하나가 0이 아닌 정수들의 최대공약수(最大公約數, 문화어: 련속나눔셈; 영어: greatest common divisor, 약자 GCD)는 공약수 가운데 가장 큰 하나다. 다항식이나 환의 원소에 대해서도 정의할 수 있다.<br>재귀방식 (logN)<br>int GCD(int a, int b) {

	if (b == 0) { return a; }
	else { return GCD(b, a%b); }
}
Run<br>반복문 방식 (logN)<br>int GCD(int a, int b) {

	while (b != 0) {
		const int r = a % b;
		a = b;
		b = r;
	}

	return a;
}
Run]]></description><link>공부\알고리즘\최대공약수.html</link><guid isPermaLink="false">공부/알고리즘/최대공약수.md</guid><pubDate>Thu, 13 Mar 2025 05:31:51 GMT</pubDate></item><item><title><![CDATA[KMP 알고리즘]]></title><description><![CDATA[ 
 <br>KMP 알고리즘<br>
불일치가 일어난 직전까지 같았던 부분을 활용하여 검색을 진행하는 것입니다. 시간 복잡도는 O(N+M)이 됩니다<br>개요<br>접두부, 접미부<br><img alt="첨부파일/algrithm/image02.png" src="lib\media\image02.png"><br>
이 때, 절대 접두부나 접미부가 문자열의 전체가 될 수 없습니다.<br>위의 예제처럼 ABCA의 접두부를 기준으로 생각해 봅시다.<br>주어진 패턴을 보면 접두부 외에 패턴내에 ABCA가 있는 것을 알 수 있습니다. 이것을 활용하고자 하는 것이 KMP 알고리즘입니다.<br>이것의 실패 필터를 만들면 다음과 같습니다.<br><br>주어진 문자열에서 ABCABCAC가 있는지 찾는 KMP 방식은 다음과 같습니다.<br>문자열과 패턴을 0번째 인덱스부터 전부 비교합니다. 이 때, 실패 필터와 비교 했을 때 같다면, 나머지 인덱스를 넘기고 해당 인덱스부터 시작합니다.<br>KMP 알고리즘은 구현이 어려운 개념이니 대체 방안으로 cstring에 strchr(strstr)함수와 int strncmp함수를 사용할 수 있습니다.<br>사용법은 다음과 같습니다.<br>]]></description><link>공부\알고리즘\kmp-알고리즘.html</link><guid isPermaLink="false">공부/알고리즘/KMP 알고리즘.md</guid><pubDate>Wed, 12 Mar 2025 06:45:40 GMT</pubDate><enclosure url="lib\media\image02.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\image02.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[LCS(Longest common subsequence; 최장 공통 부분 수열)]]></title><description><![CDATA[ 
 <br>DP를 활용하는 알고리즘입니다.<br>예를 들어<br>
ACAYKP<br>
CAPCAK<br>두 문자열의 가장 긴 공통부분 수열을 구하는 문제입니다.<br><br>다음과 같은 표를 만듭니다.<br>세로줄을 기준으로 연산을 진행하겠습니다.<br><br>같은 문자가 있다면, 왼쪽 대각선 위의 값에 +1한 값으로 바꿔 주겠습니다.<br>해당 연산을 계속 진행하면 다음과 같습니다.<br><br><br><br><br><br><br>따라서 가장 긴 공통 문자열의 길이는 2라는 사실을 알 수 있습니다.]]></description><link>공부\알고리즘\lcs(longest-common-subsequence;-최장-공통-부분-수열).html</link><guid isPermaLink="false">공부/알고리즘/LCS(Longest common subsequence; 최장 공통 부분 수열).md</guid><pubDate>Wed, 12 Mar 2025 06:06:15 GMT</pubDate></item><item><title><![CDATA[제귀함수]]></title><description><![CDATA[ 
 <br>재귀 함수는 호출한 함수 내에서 다시 함수를 호출하는 것을 말하며, 간단한 예는 다음과 같습니다.<br>int factorial(n)
{
	if(n&lt;=1) return 1;
	return n * factorial(n-1);  
}
Run<br>코드를 간단하게 해석한다면,<br>
<br>if(n&lt;=1) return 1;
<br>
<br>해당 함수에서 재귀 함수 호출을 멈추는 종료 조건입니다.
<br>
<br>return n * factorial(n-1);
<br>
<br>함수 내에서 함수를 재 호출하는 부분입니다.
<br>이 코드가 실행되는 과정을 생각해보면 다음과 같습니다.<br>만일 n == 5라면<br>
<br>종료 조건을 지나치고 return 값을 반환하기 위해 함수를 호출할 것입니다. 그 함수의 값을 반환받기 전까지는 대기할 것입니다.
<br>4번 반복합니다.
<br>이번에는 종료 조건에 부합하기에 값을 반환할 것입니다.
<br>이전에 대기하고 있던 함수가 동작하며, 값을 반환할 것입니다.
<br>재귀 함수는 동작시 <a data-href="stack" href="공부\자료구조\stack.html" class="internal-link" target="_self" rel="noopener nofollow">stack</a>의 형태로 돌아갑니다. 그리고 for문에 비해 메모리와 시간적으로 안 좋기에 기왕이면 사용하지 않는 것을 권합니다.]]></description><link>공부\자료구조\제귀함수.html</link><guid isPermaLink="false">공부/자료구조/제귀함수.md</guid><pubDate>Thu, 13 Mar 2025 07:30:47 GMT</pubDate></item><item><title><![CDATA[queue]]></title><description><![CDATA[ 
 <br><br>큐(Queue)는 선형 자료구조로, 데이터를 저장하고 검색하는 데 사용되는 중요한 자료구조입니다. 큐는 데이터를 저장할 때 "선입선출" (FIFO, First-In-First-Out) 원칙을 따릅니다. 즉, 먼저 큐에 추가된 데이터는 먼저 처리되고 제거됩니다.<br><br>
<br>데이터 요소 (Elements): 큐에 저장되는 실제 데이터 항목들로, 큐에 추가되거나 제거됩니다.
<br>프런트(Front)와 리어(Rear): 큐의 시작과 끝 지점을 나타내는 두 포인터입니다. 이들은 데이터의 추가 및 제거에 사용됩니다.
<br>리어(Rear): 큐의 끝 지점을 가리키는 포인터입니다. 큐에 추가 연산이 수행되면, 새로운 데이터가 리어에 추가됩니다.
<br><img alt="image" src="lib\media\image.png"><br>[큐 용어]<br>
<br>add() : 데이터를 추가하는 작업
<br>delete() : 데이터를 꺼내 사용하는 작업
<br>rear : 가장 최근에 추가한 데이터를 지시하는 포인터 또는 인덱스
<br>front : 사용할 데이터를 지시하는 포인터 또는 인덱스
<br>overflow : 끝까지 add()된 경우, rear == SIZE -1 일 때 add()시도하면 발생
<br>underflow : 더 이상 꺼낼 수 없는 경우, front &gt; rear 일 때 delete() 시도하면 발생
<br><br>
<br>Enqueue (데이터 추가): 큐의 리어에 데이터를 추가합니다. 새로운 데이터가 큐의 가장 뒤에 추가됩니다.
<br>Dequeue (데이터 제거): 큐의 프런트에서 데이터를 제거하고 반환합니다. 가장 먼저 추가된 데이터가 가장 먼저 제거됩니다.
<br>Peek (데이터 확인): 큐의 프런트에서 데이터를 확인하지만 제거하지 않습니다.
<br><br>
<br>선형 큐 (Linear Queue): 데이터를 FIFO 순서로 처리하는 가장 기본적인 큐<br>
<img alt="image" src="lib\media\image-1.png"><br>

<br>환형 큐 (Circular Queue): 큐의 마지막 요소가 첫 요소와 연결된 큐로, 원형으로 순환<br>
<img alt="image" src="lib\media\image-2.png"><br>

<br>우선순위 큐 (Priority Queue): 각 데이터 요소에 우선순위를 할당하고 해당 우선순위에 따라 데이터를 처리하는 큐<br>
<img alt="image" src="lib\media\image-3.png"><br>

<br>데큐(De Queue) : 양쪽에서 삽입, 삭제가 가능한 구조<br>
<img alt="image" src="lib\media\image-4.png">
<br><br>
<br>큐 (Queue): 데이터를 FIFO 순서로 처리합니다. 먼저 추가된 데이터가 먼저 제거됩니다.
<br>스택 (<a data-href="Stack" href="공부\자료구조\stack.html" class="internal-link" target="_self" rel="noopener nofollow">Stack</a>): 데이터를 LIFO 순서로 처리합니다. 가장 최근에 추가된 데이터가 가장 먼저 제거됩니다.
<br>]]></description><link>공부\자료구조\queue.html</link><guid isPermaLink="false">공부/자료구조/queue.md</guid><pubDate>Thu, 13 Mar 2025 07:27:24 GMT</pubDate><enclosure url="lib\media\image.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\image.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[stack]]></title><description><![CDATA[ 
 ]]></description><link>공부\자료구조\stack.html</link><guid isPermaLink="false">공부/자료구조/stack.md</guid><pubDate>Thu, 13 Mar 2025 07:04:20 GMT</pubDate></item><item><title><![CDATA[맵리듀스]]></title><description><![CDATA[ 
 <br>
<br>맵 : 컨테이너를 입력으로 받아, 컨테이너의 모든 원소들에 함수()를 적용하는 연산입니다.
<br><br>일 때,<br><br>
<br>리듀스 : 컨테이너의 모든 원소를 함수()를 적용하여 하나의 값으로 축약하는 연산입니다.
<br><br>일 때,<br><br>C++에서는 transform()과 accumulate() 함수를 맵과 리듀스로 제공합니다.<br>다음은 맵과 리듀스 구현의 코드입니다.<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;numeric&gt;
#include &lt;cmath&gt;
using namespace std;

void transform_test(vector&lt;int&gt; S)
{
    vector&lt;int&gt; Tr;
    cout&lt;&lt;"[맵 테스트]"&lt;&lt;endl;
    cout&lt;&lt;"입력 배열, S: ";
    for(auto i : S)
        cout&lt;&lt;i&lt;&lt;" ";
    cout&lt;&lt;endl;

    transform(S.begin(),S.end(),back_inserter(Tr),[](int x){return pow(x, 2.0);});
    cout&lt;&lt;"transform(), Tr: ";
    for(auto i : Tr)
        cout&lt;&lt;i&lt;&lt;" ";
    cout&lt;&lt;endl;

    for_each(S.begin(),S.end(),[](int &amp; x){return x=pow(x, 2.0);});
    cout&lt;&lt;"for_each(), S: ";
    for(auto i : S)
        cout&lt;&lt; i &lt;&lt; " ";
    cout&lt;&lt;endl;
}

void reduce_test(vector&lt;int&gt; S)
{
    cout&lt;&lt;endl&lt;&lt;"[리듀스 테스트]"&lt;&lt;endl;
    cout&lt;&lt;"입력 배열, S: "&lt;&lt;endl;
    for(auto i : S)
        cout&lt;&lt;i&lt;&lt;" ";
    cout&lt;&lt;endl;

    auto ans=accumulate(S.begin(),S.end(),0,[](int acc, int x){return acc+x;});
    cout&lt;&lt;"accumulate(), ans: "&lt;&lt;ans&lt;&lt;endl;
}

int main()
{
    vector&lt;int&gt; S{1,10,4,7,3,5,6,9,8,2};
    transform_test(S);
    reduce_test(S);
    return 0;
}
Run]]></description><link>공부\테크닉\맵리듀스.html</link><guid isPermaLink="false">공부/테크닉/맵리듀스.md</guid><pubDate>Wed, 12 Mar 2025 07:00:16 GMT</pubDate></item><item><title><![CDATA[배열에서의 dfs, bfs]]></title><description><![CDATA[ 
 <br>배열에서 길찾기를 하는 문제가 있을것이다. 이 때 사용할 수 있는 테크닉이다.<br>const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};

void dfs(int x, int y, char color) 
{
    visited[x][y] = true;
    for (int i = 0; i &lt; 4; ++i) 
    {
        int nx = x + dx[i];
        int ny = y + dy[i];
        if (nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; N &amp;&amp; !visited[nx][ny] &amp;&amp; grid[nx][ny] == color) 
            dfs(nx, ny, color);
    }
}
Run<br>const int dx[4] = {-1, 1, 0, 0};
const int dy[4] = {0, 0, -1, 1};
Run<br>다음은 x, y의 이동 경로이다. 인덱스를 통해서 상하좌우 이동을 제어할 수 있게 되고, if문을 사용하기 않고도 이동할 수 있다<br>if (nx &gt;= 0 &amp;&amp; nx &lt; N &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; N)
Run<br>다음은 배열범위를 초과하지 않도록 제어하는 부분이다.]]></description><link>공부\테크닉\배열에서의-dfs,-bfs.html</link><guid isPermaLink="false">공부/테크닉/배열에서의 dfs, bfs.md</guid><pubDate>Thu, 13 Mar 2025 06:43:02 GMT</pubDate></item><item><title><![CDATA[입력]]></title><description><![CDATA[ 
 <br>N개의 입력을 받을 때, for문을 사용하여 n번 입력 받았을 것이다.<br>다음과 같은 방법을 사용해도 된다.<br>vector&lt;int&gt; num(N);
for(int &amp;i:num)
    cin&gt;&gt;i;
Run]]></description><link>공부\테크닉\입력.html</link><guid isPermaLink="false">공부/테크닉/입력.md</guid><pubDate>Thu, 13 Mar 2025 06:44:56 GMT</pubDate></item><item><title><![CDATA[disjoint set]]></title><description><![CDATA[ 
 <br>#include &lt;bits/stdc++.h&gt;

using namespace std;
#define WBUF_SIZE (1 &lt;&lt; 20)

char rbuf[WBUF_SIZE];
int ridx, nidx;

inline char read() 
{
    if (ridx == nidx) 
    {
        nidx = fread(rbuf, 1, 1 &lt;&lt; 20, stdin);
        if (!nidx) return 0;
        ridx = 0;
    }
    return rbuf[ridx++];
}

inline int readInt() 
{
    int sum = 0;
    char now = read();
    bool flg = false;

    while (now &lt;= 32) now = read();
    if (now == '-') flg = true, now = read();
    while (now &gt;= 48) sum = sum * 10 + now - '0', now = read();

    return flg ? -sum : sum;
}

int arr[1000001][2]={1};

int find(int F);
void merge(int A, int B);

int main()
{
    int N,M,A,B,C;

    N = readInt();
    M = readInt();

    for(int i=0; i&lt;N+1; i++)
        arr[i][0]=i;

    for(int i=0; i&lt;M; i++)
    {
        A = readInt();
        B = readInt();
        C = readInt();

        if(A==1)
            if(find(B)==find(C))
                printf("YES\n");
            else
                printf("NO\n");
        else if(A==0)
            merge(B,C);
    }
}
  
int find(int F)
{
    if(arr[F][0]!=F)
        arr[F][0]=find(arr[F][0]);

    return arr[F][0];
}

void merge(int A, int B)
{
    if(find(A)!=find(B))
        if(arr[A][1]&gt;arr[B][1])
        {
            arr[find(B)][1]+=arr[find(A)][1];
            arr[find(A)][0]=find(B);
        }
        else
        {
            arr[find(A)][1]+=arr[find(B)][1];
            arr[find(A)][0]=find(B);
        }
}
Run<br>객체끼리의 연결성을 구하는 것인데, 해당 객체의 최상위 객체의 주소를 가져야함<br>만일 한 객체에 대해 같은 최상위 객체를 가진다면 연결된 것으로 본다<br>연결은 최상위 객체 번호를 바꾸는 것으로 한다.]]></description><link>공부\테크닉\disjoint-set.html</link><guid isPermaLink="false">공부/테크닉/disjoint set.md</guid><pubDate>Wed, 03 Jul 2024 11:27:10 GMT</pubDate></item><item><title><![CDATA[fastio]]></title><description><![CDATA[ 
 <br>가장 쉬운 c++ fastio는<br>//C와 C++과의 연동성을 제거하는 함수임
ios_base::sync_with_stdio(false);
//cin과 cout가 서로 붙어 있을때, cin이 입력을 끝낼 때까지 cout 출력이 되지 않지만 해당 함수를 사용함으로 cin이 입력 받는 중에도 출력이 됨됨
cin.tie(NULL);
Run<br>#include&lt;cstdio&gt;
#include&lt;string&gt;

using namespace std;

//버퍼의 크기를 2의 20승으로 지정, 20승인 이유는 그냥 크게 잡은 것
#define BUF_SIZE (1 &lt;&lt; 20)

//버퍼
char Readbuffer[BUF_SIZE];


//입력 함수
inline char read();
inline int readInt();
string readString();

int main(void)
{
    int N;
    string S;
    N=readInt();
    S=readString();

    //.c_str()은 char* 로 변환해주는 함수이며, 반환 값은 문자열의 시작 주소임, 즉 char[]처럼 사용가능함
    printf("%d\n%s",N*2,S.c_str());
}

inline char read()
{
    static int curr_pos, next_pos;
    if (curr_pos == next_pos)
    {
        next_pos = fread(Readbuffer, 1, 1 &lt;&lt; 20, stdin);
        if (!next_pos)
            return 0;
            
        curr_pos = 0;
    }
    return Readbuffer[curr_pos++];
}

inline int readInt() {
    int sum = 0;
    char curr = read();
    bool flag = false;

    //계행 및 공백문자 태우기
    while (curr &lt;= 32)
        curr = read();
        
    //음수를 입력 받을시 flag값을 사용하여 음수 기록
    if (curr == '-')
    {
        flag = true;
        curr = read();
    }

    //계행 및 공백 문자 나올 때 까지 입력
    while (curr &gt;= 48)
    {
        sum = sum * 10 + curr - '0';
        curr = read();
    }
    //flag 값에 따라 음수, 양수로 반환
    return flag ? -sum : sum;
}

inline string readString() {
    string result;
    char now = read();

    //계행, 공백 문자 태우기
    while (now &lt;= 32)
        now = read();

   //계행 및 공백 문자 나올 때 까지 입력
    while (now &gt; 32)
    {
        result += now;
        now = read();
    }

    return result;
}
Run]]></description><link>공부\테크닉\fastio.html</link><guid isPermaLink="false">공부/테크닉/fastio.md</guid><pubDate>Wed, 03 Jul 2024 11:19:52 GMT</pubDate></item><item><title><![CDATA[unordered map]]></title><description><![CDATA[ 
 <br>#include &lt;bits/stdc++.h&gt;
#define BUF_SIZE (1 &lt;&lt; 20)

using namespace std;

unordered_map&lt;string, pair&lt;string, int&gt;&gt; mapp;

char Readbuffer[BUF_SIZE];

inline char read();
inline int readInt();
string readString();

string find(const string &amp;F);
void merge(const string &amp;A, const string &amp;B);

int main()
{
    int N, M;
    string temp1, temp2;
    N = readInt();

    for (int i = 0; i &lt; N; i++)
    {
        cin &gt;&gt; M;
        for (int j = 0; j &lt; M; j++)
        {
            temp1= readString();
            temp2= readString();
  
            if (mapp.find(temp1) == mapp.end())
                mapp[temp1] = {temp1, 1};

            if (mapp.find(temp2) == mapp.end())
                mapp[temp2] = {temp2, 1};

            if (find(temp1) != find(temp2))
            {
                merge(temp1, temp2);
            }

            printf("%d\n",mapp[find(temp1)].second);
        }
        mapp.clear();
    }
    return 0;
}

string find(const string &amp;F)
{
    if (mapp[F].first != F)
        mapp[F].first = find(mapp[F].first);
    return mapp[F].first;
}

void merge(const string &amp;A, const string &amp;B)
{
    string rootA = find(A);
    string rootB = find(B);

    if (rootA != rootB)
    {
        if (mapp[rootA].second &gt; mapp[rootB].second)
        {
            mapp[rootB].first = rootA;
            mapp[rootA].second += mapp[rootB].second;
        }
        else
        {
            mapp[rootA].first = rootB;
            mapp[rootB].second += mapp[rootA].second;
        }
    }
}

inline char read() {
    static int curr_pos = 0, next_pos = 0;
    if (curr_pos == next_pos) {
        next_pos = fread(Readbuffer, 1, 1, stdin);
        if (next_pos == 0) return 0;
        curr_pos = 0;
    }
    return Readbuffer[curr_pos++];
}

inline int readInt() {
    int sum = 0;
    char curr = read();
    bool flag = false;
    
    while (curr &lt;= 32)
        curr = read();

    if (curr == '-') {
        flag = true;
        curr = read();
    }

    while (curr &gt;= '0' &amp;&amp; curr &lt;= '9') {
        sum = sum * 10 + curr - '0';
        curr = read();
    }

    return flag ? -sum : sum;
}

  

inline string readString() {
    string result;
    char now = read();

    while (now &lt;= 32)
        now = read();

    while (now &gt; 32) {
        result += now;
        now = read();
    }

    return result;
}
Run<br><img alt="Pasted image 20240703211629.png" src="lib\media\pasted-image-20240703211629.png"><br>그냥 map을 사용했을시에 시간은 700ms인 반면 unordered_map의 경우 220ms가 걸린다<br>map은 기록할 때 순회하여 기록하나, unordered_map은 무작위 기록하기에 빠르다.]]></description><link>공부\테크닉\unordered-map.html</link><guid isPermaLink="false">공부/테크닉/unordered map.md</guid><pubDate>Wed, 03 Jul 2024 12:17:47 GMT</pubDate><enclosure url="lib\media\pasted-image-20240703211629.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240703211629.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(G1)1114 통나무 자르기]]></title><description><![CDATA[ 
 <br><br>벌목꾼 백은진은 나무를 종이 공장에 옮겨야 한다. 하지만, 통나무의 길이가 너무 길어서 트럭에 들어가지 않으므로, 여러개의 조각으로 나누려고 한다.<br>통나무의 길이는 L이고, K개의 위치에서만 자를 수 있다. 통나무를 자를 수 있는 위치가 주어진다.&nbsp;이 위치는 통나무의 가장 왼쪽에서부터 떨어진 거리이다. 통나무를 자를 수 있는 횟수는 최대 C번이다.<br>통나무의 가장 긴 조각을 작게 만들고, 그 길이를 구해보자.<br><br>첫째 줄에 세 정수 L, K, C가 주어진다. 둘째 줄에는 통나무를 자를 수 있는 위치가 주어진다.<br><br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std; 

vector&lt;int&gt; arr;
long long L, C, K;

bool possible(int mid) 
{
    int cut = 0, sum = 0;
    
    for (int i = 1; i &lt; arr.size(); ++i) 
    {
        if (arr[i] - arr[i - 1] &gt; mid)
            return false;
        if (sum + arr[i] - arr[i - 1] &gt; mid) 
        {
            cut++;
            sum = arr[i] - arr[i - 1];
        } 
        else 
            sum += arr[i] - arr[i - 1];
    }
    return cut &lt;= C;
}

long long binarySearch() 
{
    long long low = 0, high = L;
    while (low + 1 &lt; high) 
    {
        long long mid = (low + high) / 2;
        if (possible(mid))
            high = mid;
        else
            low = mid;
    }
    return high;
}


int main() 
{
    cin &gt;&gt; L &gt;&gt; K &gt;&gt; C;
    arr.resize(K + 1);
    for (int i = 1; i &lt;= K; ++i) 
        cin &gt;&gt; arr[i];
    arr.emplace_back(L);
    sort(arr.begin(), arr.end());

    long long max_length = binarySearch();
  
    int index = K, sum = 0, cuts_left = C;
    for (int i = arr.size() - 1; i &gt; 0; --i) 
    {
        if (sum + arr[i] - arr[i - 1] &gt; max_length) 
        {
            sum = arr[i] - arr[i - 1];
            cuts_left--;
            index = i;
        } 
        else
            sum += arr[i] - arr[i - 1];
    }
    if (cuts_left &gt; 0) 
	    index = 1;
    cout &lt;&lt; max_length &lt;&lt; " " &lt;&lt; arr[index] &lt;&lt; endl;

    return 0;
}
Run<br>위의 코드는 통나무를 전부 자르는 것이 아닌 자를 수 있는지 여부만 판단하여 통나무의 최대길이와 최대길이를 토재로 처음 자른 부분을 계산하도록 설계되었습니다.<br>우선 이진 탐색을 통해, 통나무를 반절로 자를 수 있는지 확인합니다. 자를 수 있는지 여부는 possible 함수를 통하여 구하게 되고, 자를 수 있다면, 더 작은 범위도 자를 수 있는지 확인합니다.<br>
(high가 mid이 되면 범위가 줄고, low가 mid가 되면 범위가 늘어난다.)<br>코드에 대한 설명은 다음과 같습니다.<br>if (arr[i] - arr[i - 1] &gt; mid)
            return false;
Run<br>통나무의 절반이 3이라고 가정할 때, 3만큼으로 자르는 방법은 3으로 자르는 방법도 있지만,<br>
10으로 자른 통나무의 오른쪽 부터 7만큼 자른다면 왼쪽에는 3만큼 남을 것입니다.<br>if (sum + arr[i] - arr[i - 1] &gt; mid) 
        {
            cut++;
            sum = arr[i] - arr[i - 1];
        } 
        else 
            sum += arr[i] - arr[i - 1];
Run<br>조건문의 else 부분은 해당 부분 합을 누적하여 mid를 초과하는지 확인하는 것입니다.<br>
12345로 예시를 들면<br>2-1 : (1/1) sum=1<br>
3-2+sum(2에서 1로 나눈 것) : (1/1/1)<br>
4-3+sum: (1/1/1) : mid 초과 그래서 한번 자름<br>
5-4+sum: (1) : sum=2<br>이런 식으로 진행됨<br>이 과정에서 자른 수가 C번 이하일 수 있는지 확인하여 반환함<br>int index = K, sum = 0, cuts_left = C;
    for (int i = arr.size() - 1; i &gt; 0; --i) 
    {
        if (sum + arr[i] - arr[i - 1] &gt; max_length) 
        {
            sum = arr[i] - arr[i - 1];
            cuts_left--;
            index = i;
        } 
        else
            sum += arr[i] - arr[i - 1];
    }
    if (cuts_left &gt; 0) 
	    index = 1;
Run<br>cuts_left는 총 자를 수 있는 횟수로 자를 때마다 1씩 줄어들어 최대한 자를 수 있는데 까지 자릅니다.<br>
만일 해당 변수가 0보다 크다면 자를 횟수가 여유가 있기에 mid 사이즈로 자를 수 있습니다.<br>if문은 possible의 if문과 거의 유사합니다.<br>index는 이진 검색으로 구한 max_length보다 큰 값이라면 자르고 자른 부분을 인덱스로 가집니다.<br>ex) 만일 13456의 경우는 다음과 같다고 생각하면 됨<br>
((((1/23)4)5)6)<br>
6안에 5를 포함, 해당 5에 4를 포함, 4에 3을 포함, 3에 1을 포함<br>
이 때, 최대 2까지 처리할 수 있을 것임<br>mid가 3이라면 3을 넘길 때마 잘라주면 됨]]></description><link>공부\coding\백준풀이\(g1)1114-통나무-자르기.html</link><guid isPermaLink="false">공부/coding/백준풀이/(G1)1114 통나무 자르기.md</guid><pubDate>Thu, 13 Mar 2025 05:43:43 GMT</pubDate></item><item><title><![CDATA[(G3)15685 드래곤커브]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/15685" target="_blank">https://www.acmicpc.net/problem/15685</a><br><br>드래곤 커브는 다음과 같은 세 가지 속성으로 이루어져 있으며, 이차원 좌표 평면 위에서 정의된다. 좌표 평면의 x축은&nbsp;→ 방향, y축은&nbsp;↓ 방향이다.<br>
<br>시작 점
<br>시작 방향
<br>세대
<br>0세대 드래곤 커브는 아래 그림과 같은 길이가 1인 선분이다. 아래 그림은 (0, 0)에서 시작하고, 시작 방향은 오른쪽인 0세대 드래곤 커브이다.<br><img src="http://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/1.png" referrerpolicy="no-referrer"><br>1세대 드래곤 커브는 0세대 드래곤 커브를 끝 점을 기준으로 시계 방향으로 90도 회전시킨 다음 0세대 드래곤 커브의 끝 점에 붙인 것이다. 끝 점이란 시작 점에서 선분을 타고 이동했을 때, 가장 먼 거리에 있는 점을 의미한다.<br><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/2.png" referrerpolicy="no-referrer"><br>2세대 드래곤 커브도 1세대를 만든 방법을 이용해서&nbsp;만들 수 있다. (파란색 선분은 새로 추가된 선분을 나타낸다)<br><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/3.png" referrerpolicy="no-referrer"><br>3세대 드래곤 커브도 2세대 드래곤 커브를 이용해 만들 수 있다. 아래 그림은 3세대 드래곤 커브이다.<br><img src="https://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/4.png" referrerpolicy="no-referrer"><br>즉, K(K &gt; 1)세대 드래곤 커브는 K-1세대 드래곤 커브를&nbsp;끝 점을 기준으로 90도 시계 방향 회전 시킨 다음, 그것을 끝 점에&nbsp;붙인 것이다.<br>크기가 100×100인 격자 위에 드래곤 커브가 N개 있다. 이때, 크기가 1×1인 정사각형의 네 꼭짓점이 모두 드래곤 커브의 일부인 정사각형의 개수를 구하는 프로그램을 작성하시오. 격자의 좌표는 (x, y)로 나타내며, 0 ≤ x ≤ 100, 0 ≤ y ≤ 100만 유효한 좌표이다.<br><br>첫째 줄에 드래곤 커브의 개수 N(1 ≤ N ≤ 20)이 주어진다. 둘째 줄부터 N개의 줄에는 드래곤 커브의 정보가 주어진다. 드래곤 커브의 정보는 네&nbsp;정수 x, y, d, g로 이루어져 있다. x와 y는 드래곤 커브의 시작 점, d는 시작 방향, g는 세대이다. (0 ≤ x, y ≤ 100, 0 ≤ d ≤ 3, 0 ≤ g ≤ 10)<br>입력으로 주어지는 드래곤 커브는 격자 밖으로 벗어나지 않는다. 드래곤 커브는 서로 겹칠 수 있다.<br>방향은 0, 1, 2, 3 중 하나이고, 다음을 의미한다.<br>
<br>0: x좌표가 증가하는 방향 (→)
<br>1: y좌표가 감소하는 방향 (↑)
<br>2: x좌표가 감소하는 방향 (←)
<br>3: y좌표가 증가하는 방향 (↓)
<br><br>느낌<br><br>무언가 피라미드 느낌]]></description><link>공부\coding\백준풀이\(g3)15685-드래곤커브.html</link><guid isPermaLink="false">공부/coding/백준풀이/(G3)15685 드래곤커브.md</guid><pubDate>Sat, 01 Jun 2024 06:56:57 GMT</pubDate><enclosure url="http://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;http://onlinejudgeimages.s3-ap-northeast-1.amazonaws.com/problem/15685/1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[(G3)16236 아기상어]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/16236" target="_blank">https://www.acmicpc.net/problem/16236</a><br><br>N×N 크기의 공간에 물고기 M마리와 아기 상어 1마리가 있다. 공간은 1×1 크기의 정사각형 칸으로 나누어져 있다. 한 칸에는 물고기가 최대 1마리 존재한다.<br>아기 상어와 물고기는 모두 크기를 가지고 있고, 이 크기는 자연수이다. 가장 처음에 아기 상어의 크기는 2이고, 아기 상어는 1초에 상하좌우로 인접한 한 칸씩 이동한다.<br>아기 상어는 자신의 크기보다 큰 물고기가 있는 칸은 지나갈 수 없고, 나머지 칸은 모두 지나갈 수 있다. 아기 상어는 자신의 크기보다 작은 물고기만 먹을 수 있다. 따라서, 크기가 같은 물고기는 먹을 수 없지만, 그 물고기가 있는 칸은 지나갈 수 있다.<br>아기 상어가 어디로 이동할지 결정하는 방법은 아래와 같다.<br>
<br>더 이상 먹을 수 있는 물고기가 공간에 없다면 아기 상어는 엄마 상어에게 도움을 요청한다.
<br>먹을 수 있는 물고기가 1마리라면, 그 물고기를 먹으러 간다.
<br>먹을 수 있는 물고기가 1마리보다 많다면, 거리가 가장 가까운 물고기를 먹으러 간다.

<br>거리는 아기 상어가 있는 칸에서 물고기가 있는 칸으로 이동할 때, 지나야하는 칸의 개수의 최솟값이다.
<br>거리가 가까운 물고기가 많다면, 가장&nbsp;위에 있는 물고기, 그러한 물고기가 여러마리라면, 가장 왼쪽에 있는 물고기를 먹는다.


<br>아기 상어의 이동은 1초 걸리고, 물고기를 먹는데 걸리는 시간은 없다고 가정한다. 즉, 아기 상어가 먹을 수 있는 물고기가 있는 칸으로 이동했다면, 이동과 동시에 물고기를 먹는다. 물고기를 먹으면, 그 칸은 빈 칸이 된다.<br>아기 상어는 자신의 크기와 같은 수의 물고기를 먹을 때 마다 크기가 1 증가한다. 예를 들어, 크기가 2인 아기 상어는 물고기를 2마리 먹으면 크기가 3이 된다.<br>공간의 상태가 주어졌을 때, 아기 상어가 몇 초 동안 엄마 상어에게 도움을 요청하지 않고 물고기를 잡아먹을 수&nbsp;있는지 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 공간의 크기 N(2&nbsp;≤ N ≤ 20)이 주어진다.<br>둘째 줄부터 N개의 줄에 공간의 상태가 주어진다. 공간의 상태는 0, 1, 2, 3, 4, 5, 6, 9로 이루어져 있고, 아래와 같은 의미를 가진다.<br>
<br>0: 빈 칸
<br>1, 2, 3, 4, 5, 6: 칸에 있는 물고기의 크기
<br>9: 아기 상어의 위치
<br>아기 상어는 공간에 한 마리 있다.<br>]]></description><link>공부\coding\백준풀이\(g3)16236-아기상어.html</link><guid isPermaLink="false">공부/coding/백준풀이/(G3)16236 아기상어.md</guid><pubDate>Fri, 31 May 2024 08:33:47 GMT</pubDate></item><item><title><![CDATA[양 한마리... 양 A마리... 양 A제곱마리...]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/30413" target="_blank">https://www.acmicpc.net/problem/30413</a><br><br><br>춘배는 오늘도 열심히 활동을 마친 후 자려 하지만 도저히 잠이 안 온다. 춘배는 잠을 자기 위해 자신만의 방법으로 양을 세려는데 한 마리씩 세지 않고 여러 마리를 한꺼번에 세면서 자려 한다.<br>춘배는 일단 양의 정수<br>
를 정한다. 그 후 양을 셀 때 첫 번째에 센 양의 수는 항상<br>
로 두고, 그 뒤 두 번째에 센 양의 수는<br>
, 세 번째에 센 양의 수는<br>
 이렇게 점점 양의 수를 세어 간다. 즉,<br>
번째에 센 양의 수는<br>
 가 된다.<br>춘배는 이러한 방식으로 양을 세다 문득 자신이 첫 번째부터<br>
번째까지 센 모든 양의 수가 얼마나 될지 궁금해졌다. 춘배를 위해 첫 번째부터 마지막<br>
번째까지 센 모든 양의 수가 몇 마리인지 구해보자! 하지만 수가 너무 커질 수 있기에<br>
로 나눈 나머지를 구하자.<br><br>첫 번째 줄에 양의 정수<br>
,<br>
 가 공백으로 구분되어 주어진다.<br>
,<br>
$ 1 \le B \le 10^{12})$ <br><br>첫 번째부터<br>
번째까지 센 모든 양의 수를<br>
로 나눈 나머지를 출력한다.<br><br>해당 문제는 등비수열을 활용하는 문제로 수식은 다음과 같습니다.<br><br>여기서 N은 등비, M은 항수입니다.<br>이 문제에서 첫째항은 항상 1이라 하였기에 이를 활용하여 코드를 작성하면<br>#include &lt;iostream&gt;

using namespace std;

#define MOD 1000000007

long long power(long long base, long long exp);

int main() {
    long long N, M, A, B;
    cin &gt;&gt; N &gt;&gt; M;

    A=(power(N,M)-1)%MOD;
    B=(power(N-1, MOD-2))%MOD;


    if(N==1)
        cout&lt;&lt;(N*M)%MOD;
    else
        cout&lt;&lt; (A*B)%MOD &lt;&lt; endl;



    return 0;
}


long long power(long long base, long long exp) {
    long long result = 1;
    while (exp &gt; 0) 
    {
        if (exp % 2 == 1) 
        {
            result = (result * base) % MOD;
        }
        base = (base * base) % MOD;
        exp /= 2;
    }
    return result;
}
Run<br><br>제곱을 구하기 위해 사용<br><br>N이 1일 경우 수식이 0이 되어 오답이 됨]]></description><link>공부\coding\백준풀이\(g3)30413-양-한마리,-양-a마리,-양-a제곱마리.html</link><guid isPermaLink="false">공부/coding/백준풀이/(G3)30413 양 한마리, 양 A마리, 양 A제곱마리.md</guid><pubDate>Thu, 13 Mar 2025 05:44:45 GMT</pubDate></item><item><title><![CDATA[부분합]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1806" target="_blank">https://www.acmicpc.net/problem/1806</a><br><br><br>자바의 경우 1초까지 허용<br><br>10,000 이하의 자연수로 이루어진 길이 N짜리 수열이 주어진다. 이 수열에서 연속된 수들의 부분합 중에 그 합이 S 이상이 되는 것 중, 가장 짧은 것의 길이를 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N (10 ≤ N &lt; 100,000)과 S (0 &lt; S ≤ 100,000,000)가 주어진다. 둘째 줄에는 수열이 주어진다. 수열의 각 원소는 공백으로 구분되어져 있으며, 10,000이하의 자연수이다.<br><br>첫째 줄에 구하고자 하는 최소의 길이를 출력한다. 만일 그러한 합을 만드는 것이 불가능하다면 0을 출력하면 된다.<br><br>#include&lt;iostream&gt;
#include&lt;vector&gt;
#include&lt;algorithm&gt;
#include&lt;climits&gt;
using namespace std;
int arr[100001];
int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    long N, M;
    cin &gt;&gt; N &gt;&gt; M;
    arr[0] = 0;
    for(int i = 1; i &lt;= N; i++)
    {
        cin &gt;&gt; arr[i];
        arr[i] += arr[i - 1];
    }
    int result = INT_MAX;
    for(int start = 0; start &lt;= N; start++)
    {
        int end = lower_bound(arr + start, arr + N + 1, M + arr[start]) - arr;
        if (end &lt;= N)
            result = min(result, end - start);
    }
    cout &lt;&lt; (result == INT_MAX ? 0 : result) &lt;&lt; endl;
    return 0;
}
Run<br><br>다른 문제와 달리 시간 제한이 0.5 초이기에, 최대한 빠른 시간내에 문제를 풀수 있어야함.<br><br>int arr[100001];
Run<br>ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
Run<br><br> arr[0] = 0;
    for(int i = 1; i &lt;= N; i++)
    {
        cin &gt;&gt; arr[i];
        arr[i] += arr[i - 1];
    }
Run<br>arr의 인덱스의 0번을 0으로 저장한 이유는, 누적합 입력을 편하게 받기 위해 사용<br><br>    int result = INT_MAX;
Run<br>    cout &lt;&lt; (result == INT_MAX ? 0 : result) &lt;&lt; endl;
Run<br> result의 초기값은 INT_MAX로 초기화 되어있고, 다음 소개할 코드에서 값이 변하지 않았다면 0을 출력, 변하였다면 result를 출력하게 되어있습니다.<br><br>for(int start = 0; start &lt;= N; start++)
   {
       int end = lower_bound(arr + start, arr + N + 1, M + arr[start]) - arr;
       if (end &lt;= N)
           result = min(result, end - start);
   }
Run<br>
<br>lower_bound<br><br>
전달인자로 3가지를 받는 데,
<br>
<br>배열의 시작 주소
<br>배열의 끝 주소
<br>찾고자 하는 값<br><br>
만일 찾고자 하는 값보다 큰 값을 찾았다면, 해당 값의 주소를 반환합니다.<br><br>
만일 찾지 못하였다면, 2번째 전달인자의 다음 위치를 반환합니다.
<br>다음 반복문은 끝 위치는 고정한채 시작위치를 변경하여 시작점과 끝 점의 길이가 가장 짧은 위치를 찾는 코드입니다. 문제의 예시를 기준으로 다음과 같이 작동할 것입니다.<br><br><br><br>if문 조건에 따라 N보다 큰 값은 포함하지 않음으로 값을 찾을 수 있는 범위에서 동작할 것입니다.<br><br>
만일 if문이 존재하지 않는다면 결과는 항상 1이 출력될 것입니다.]]></description><link>공부\coding\백준풀이\(g4)1806부분합.html</link><guid isPermaLink="false">공부/coding/백준풀이/(G4)1806부분합.md</guid><pubDate>Thu, 13 Mar 2025 05:45:47 GMT</pubDate></item><item><title><![CDATA[(G5)9251 LCS]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/9251" target="_blank">https://www.acmicpc.net/problem/9251</a><br><br>LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.<br>예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.<br><br>첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.<br><br>값이 전부 0인 2차원 배열을 만든 후, A의 첫 글자부터 끝 글자까지 B의 글자와 비교하고 같다면, 우측 대각선 위의 값에 +1한 값을 저장해줍니다.<br>기존의 LCS는 이것으로 마무리이지만, 이 문제는 연속될 필요는 없다는 조건이 있기에 만일 글자가 같지 않다면 우측과 위를 조사하여 큰 숫자로 최신화하게 해 주었습니다.<br>#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;algorithm&gt;

using namespace std;

int main()
{
    string A,B;
    cin&gt;&gt;A&gt;&gt;B;

    int M=A.length();
    int N=B.length();

    int dp[M+1][N+1];
    for (int i = 0; i &lt;= M; i++)
        for (int j = 0; j &lt;= N; j++)
            dp[i][j] = 0;
            
    for(int i=1; i&lt;=M; i++)
    {
        for(int j=1; j&lt;=N; j++)
        {
            if(A[i-1]==B[j-1])
                dp[i][j]=dp[i-1][j-1]+1;
            else
                dp[i][j]=max(dp[i-1][j],dp[i][j-1]);
        }
    }

    cout&lt;&lt;dp[M][N];

    return 0;

}
Run]]></description><link>공부\coding\백준풀이\(g5)9251-lcs.html</link><guid isPermaLink="false">공부/coding/백준풀이/(G5)9251 LCS.md</guid><pubDate>Thu, 13 Mar 2025 05:46:05 GMT</pubDate></item><item><title><![CDATA[(G5)15686 치킨배달]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/15686" target="_blank">https://www.acmicpc.net/problem/15686</a><br><br>크기가 N×N인 도시가 있다. 도시는 1×1크기의 칸으로 나누어져 있다. 도시의 각 칸은 빈 칸, 치킨집, 집 중 하나이다. 도시의 칸은 (r, c)와 같은 형태로 나타내고, r행 c열 또는 위에서부터 r번째 칸, 왼쪽에서부터 c번째 칸을 의미한다. r과 c는 1부터 시작한다.<br>이 도시에 사는 사람들은 치킨을 매우 좋아한다. 따라서, 사람들은&nbsp;"치킨 거리"라는 말을 주로 사용한다.&nbsp;치킨 거리는 집과 가장 가까운 치킨집 사이의&nbsp;거리이다. 즉, 치킨 거리는 집을 기준으로 정해지며, 각각의 집은&nbsp;치킨 거리를 가지고 있다.&nbsp;도시의 치킨 거리는 모든 집의&nbsp;치킨 거리의 합이다.<br>임의의 두 칸 (r1, c1)과 (r2, c2) 사이의 거리는 |r1-r2| + |c1-c2|로 구한다.<br>예를 들어, 아래와 같은 지도를 갖는 도시를 살펴보자.<br>0 2 0 1 0<br>
1 0 1 0 0<br>
0 0 0 0 0<br>
0 0 0 1 1<br>
0 0 0 1 2<br>0은 빈 칸, 1은 집, 2는 치킨집이다.<br>(2, 1)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |2-1| + |1-2| = 2, (5, 5)에 있는 치킨집과의 거리는 |2-5| + |1-5| = 7이다. 따라서, (2, 1)에 있는 집의 치킨 거리는 2이다.<br>(5, 4)에 있는 집과 (1, 2)에 있는 치킨집과의 거리는 |5-1| + |4-2| = 6,&nbsp;(5, 5)에 있는 치킨집과의 거리는 |5-5| + |4-5| = 1이다. 따라서, (5, 4)에 있는 집의 치킨 거리는 1이다.<br>이 도시에 있는 치킨집은 모두 같은 프랜차이즈이다. 프렌차이즈 본사에서는 수익을 증가시키기 위해 일부 치킨집을 폐업시키려고 한다. 오랜 연구 끝에 이 도시에서 가장 수익을 많이 낼 수 있는 &nbsp;치킨집의 개수는 최대 M개라는 사실을 알아내었다.<br>도시에 있는 치킨집 중에서 최대 M개를 고르고, 나머지 치킨집은 모두 폐업시켜야 한다. 어떻게&nbsp;고르면,&nbsp;도시의 치킨 거리가 가장 작게 될지 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N(2&nbsp;≤ N ≤ 50)과 M(1 ≤ M ≤ 13)이 주어진다.<br>둘째 줄부터 N개의 줄에는 도시의 정보가 주어진다.<br>도시의 정보는 0, 1, 2로 이루어져 있고, 0은 빈 칸, 1은 집, 2는 치킨집을 의미한다. 집의 개수는 2N개를 넘지 않으며, 적어도 1개는 존재한다. 치킨집의 개수는 M보다 크거나 같고, 13보다 작거나 같다.<br><br><br>#include &lt;bits/stdc++.h&gt;

using namespace std; 

int city[50][50];

vector&lt;pair&lt;int, int&gt;&gt; home;
vector&lt;pair&lt;int, int&gt;&gt; chicken;
vector&lt;pair&lt;int, int&gt;&gt; temp;
int mindistance[101];
int ans=INT_MAX;

int Distance(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b);
void HomeToChicken(int M);
void recursion(int M, int count, int index);

int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(NULL);
    
    int N,M;
    cin&gt;&gt;N&gt;&gt;M;
  
    for(int i=0; i&lt;N; i++)
        for(int j=0; j&lt;N; j++)
        {
            cin&gt;&gt;city[i][j];
            if(city[i][j]==1)
                home.push_back(make_pair(i,j));
            else if(city[i][j]==2)
                chicken.push_back(make_pair(i,j));
        }

    recursion(M,0,0);

    cout&lt;&lt;ans;
}

int Distance(pair&lt;int, int&gt; a, pair&lt;int, int&gt; b)
{
    return abs(a.first-b.first)+ abs(a.second-b.second);
}

void HomeToChicken()
{
    for (int i = 0; i &lt; 101; i++)
        mindistance[i] = INT_MAX;

    int sum=0;

    for(int i=0; i&lt;home.size(); i++)
        for(int j=0; j&lt;temp.size(); j++)
            mindistance[i]=min(mindistance[i], abs(Distance(home[i], temp[j])));

    for(int i=0; i&lt;home.size(); i++)
        sum+=mindistance[i];

    ans=min(ans, sum);
}

  

void recursion(int M, int count, int index)
{
    if(count==M)
    {
        HomeToChicken();
        return;
    }

    for(int i=index; i&lt;chicken.size();i++)
    {
        temp.push_back(chicken[i]);
        recursion(M,count+1,i+1);
        temp.pop_back();
    }
}
Run<br><br>
<br>
Distance<br>
매개 변수로 pair&lt;int, int&gt; 두 개를 받고, 두 좌표의 거리를 구함

<br>
HomeToChicken<br>
recursion 함수에서 뽑은 치킨 집들 중, 가장 가까운 치킨집과의 거리를 mindistance 배열에 저장 한후  더하는 함수,

<br>mindistance 배열은 재 사용하기에 다시 INT_MAX로 초기화 시켜줘야 함<br>
<br>recursion<br>
간단히 설명하면,<br>
count는 현재까지 선택한 치킨집의 수,<br>
index는 선택하려 하는 집을 나타냄
<br>함수를 보면 알 수 있듯, M개로 만들 수 있는 모든 조합 만을 조사한다.]]></description><link>공부\coding\백준풀이\(g5)15686-치킨배달.html</link><guid isPermaLink="false">공부/coding/백준풀이/(G5)15686 치킨배달.md</guid><pubDate>Thu, 13 Mar 2025 05:46:44 GMT</pubDate></item><item><title><![CDATA[3197번 백조의 호수]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/3197" target="_blank">https://www.acmicpc.net/problem/3197</a><br><br><br>두 마리의 백조가 호수에서 살고 있었다. 그렇지만 두 마리는 호수를 덮고 있는 빙판으로 만나지 못한다.<br>호수는 행이 R개, 열이 C개인 직사각형 모양이다. 어떤 칸은 얼음으로 덮여있다.<br>호수는 차례로 녹는데, 매일 물 공간과 접촉한 모든 빙판 공간은 녹는다. 두 개의 공간이 접촉하려면 가로나 세로로 닿아 있는 것만 (대각선은 고려하지 않는다) 생각한다.<br>백조는 오직 물 공간에서 세로나 가로로만(대각선은 제외한다) 움직일 수 있다.<br>며칠이 지나야 백조들이 만날 수 있는 지 계산하는 프로그램을 작성하시오.<br><br>입력의 첫째 줄에는 R과 C가 주어진다. 단, 1 ≤ R, C ≤ 1500.<br>다음 R개의 줄에는 각각 길이 C의 문자열이 하나씩 주어진다. '.'은 물 공간, 'X'는 빙판 공간, 'L'은 백조가 있는 공간으로 나타낸다.<br><br>첫째 줄에 문제에서 주어진 걸리는 날을 출력한다.<br><br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;

using namespace std;

int M,N;
bool found=false;

char map[1500][1500];
bool visited[1500][1500]={false};
//방문한 정점 기록(방문한 정점에 대해서 조사하지 않기 위해)

int dx[] = {0, 0, 1, -1};
int dy[] = {1, -1, 0, 0};
//상하좌우 이동할 때, 좌표에 더해야 하는 값

queue&lt;pair&lt;int,int&gt;&gt; Q,NQ,SQ,SNQ; 
//Q와 NQ는 BFS_water, SQ와 SNQ는 BFS_swan
//NQ는 얼음이 녹을 때, 기록하기 위함 다음 번에 조사할 Q
//SQ는 백조가 방문 가능한 물에 방문기록 visited를 기록하기 위함
//SNQ는 현재는 얼음이지만 추후 백조가 갈 수 있는 공간을 표시
pair&lt;int,int&gt; swan;

void input();
void BFS_water();
void BFS_swan();
void SOL();

int main()
{
    ios::sync_with_stdio(false);
    cin.tie(NULL);
    cout.tie(NULL);
    input();
    SOL();
}

void input()
{
    cin&gt;&gt;N&gt;&gt;M;
    for(int i=0; i&lt;N; i++)
    {
        for(int j=0; j&lt;M; j++)
        {
            cin&gt;&gt;map[i][j];
            if(map[i][j]!='X')
            {
                // 처음에는 물과 백조에서 모두 조사해야 하기에 얼음을 제외한 모든 값을 기록
                Q.push(make_pair(i,j));
            }
            
            if(map[i][j]=='L')
            {
                //백조는 어디서 측정하든 상관 없음으로 한 개만 기록
                swan.first = i;
                swan.second =j;
            }
        }
    }
}

void BFS_water()
{
    while(!Q.empty())
    {
        int x = Q.front().first;
        int y = Q.front().second;
        Q.pop();

        for(int i = 0; i &lt; 4; i++)//상하좌우 이동
        {
            int nx = x+dx[i];
            int ny = y+dy[i];

            if(nx&gt;=0 &amp;&amp; ny&gt;=0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt;M)//범위가 초과하지 않도록 하기 위함
            {
                if(map[nx][ny]=='X')//얼음을 녹이고, 다음에 녹기 시작할 좌표를 NQ에 저장
                {
                    map[nx][ny]='.';
                    NQ.push(make_pair(nx,ny));
                }
            }
        }
    }
    Q=NQ;
    while(!NQ.empty())
    {
        //NQ를 재사용하기에 비워줘야 함
        NQ.pop();
    }
}

void BFS_swan()
{
    while(!SQ.empty())
    {
        int x = SQ.front().first;
        int y = SQ.front().second;
        SQ.pop();

        for(int i = 0; i &lt; 4; i++)//상하좌우 이동
        {
            int nx = x + dx[i];
            int ny = y + dy[i];
            if(nx&gt;=0 &amp;&amp; ny&gt;=0 &amp;&amp; nx &lt; N &amp;&amp; ny &lt;M)//범위가 초과하지 않도록 하기 위함
            {
                if(visited[nx][ny]==false)//방문한 곳을 다시 방문하지 않기 위해
                {
                    if(map[nx][ny]=='.')//물이라면
                    {
                        visited[nx][ny]=true;//방문 했음
                        SQ.push(make_pair(nx, ny));//해당 위치에서 다시 조사 해야함
                    }
                    else if (map[nx][ny]=='X')//얼음이라면
                    {
                        visited[nx][ny]= true;//방문 했음
                        SNQ.push(make_pair(nx,ny));//다음 번에는 이 얼음은 녹을 것임으로 조사대상임
                    }
                    else if(map[nx][ny]=='L')
                    {
                        found=true;//백조를 찾음
                        break;
                    }
                }
            }
        }
    }
    SQ=SNQ;
    while(!SNQ.empty())
    {
        //SNQ는 재사용해야하기에 비움
        SNQ.pop();
    }
}

void SOL()
{
    int count=0;//만날 날짜
    visited[swan.first][swan.second]=true;//백조의 위치는 방문한 것으로 처리
    SQ.push(make_pair(swan.first, swan.second));//백조 위치부터 조사 시작
    while(!found)//백조가 발견되지 않았다면
    {
        BFS_swan();
        if(!found)
        {
            BFS_water();
            count++;
        }
    }
    cout&lt;&lt;count;

}
Run]]></description><link>공부\coding\백준풀이\(p5)3197-백조의-호수.html</link><guid isPermaLink="false">공부/coding/백준풀이/(P5)3197 백조의 호수.md</guid><pubDate>Thu, 13 Mar 2025 05:47:39 GMT</pubDate></item><item><title><![CDATA[(S1)1391 음하철도 구구팔]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/1393" target="_blank">https://www.acmicpc.net/problem/1393</a><br><br>최백준은 음하철도 구구팔에 탔다.<br>문제는 구구팔의 기장인 조교 김재홍이 반쯤 미쳐서 열차를 멈추지 않는다는 것이다. 그래서&nbsp;최백준은 달리고 있는 열차에서 뛰어내려야 한다.<br>그런데 뛰어내릴 때 정류장 까지 거리가 너무 멀면 마이 아플 수 있다.<br>그래서 철도가 정류장에 가장 많이 근접했을 때 뛰어내리고자 한다.<br>어디서 뛰어내려야 하는가?<br><br>첫번째 줄에는 xs와 ys가 주어진다. 이는 정류장의 위치가 (xs, ys)임을 의미한다.<br>두번째 줄에는 xe, ye, dx, dy가 주어진다. 이는 현재 열차 위치가 (xe, ye)이고, 열차가 1초마다 x가 증가하는 방향으로 dx만큼, y가 증가하는 방향으로 dy만큼 이동함을 의미한다<br>주어지는 모든 수는 -100이상, 100이하의 정수이다.<br><br>시간이 흐를 때마다의 거리를 이전 거리와 비교하여 이전값보다 길어졌다면, 이전값을 출력하여 해결하였다.<br>이 경우 dx 혹은 dy가 0일 가능성이 존재한다.<br>dx가 0이라면, dy값이 몇이던 간에 상관이 없음으로 dy를 1로 변경한다.<br>
dy가 0이라면, dx값이 몇이던 간에 상관이 없음으로 dx를 1로 변경한다.<br>둘 다 0이 아니라면 최대 공약수를 구하여 그 값을 나눠준다.<br>
증가치가 (2,4)일 때, (1,2)가 증가한 시점에서 동작할 수 있음으로<br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;
#include &lt;cmath&gt;

using namespace std;

int xs, ys, xe, ye, dx, dy,result_x,result_y;
double predistance;
 
double Distance(int x, int y)
{
    double tmp = pow((x - xs), 2) + pow((y - ys), 2);
    return tmp;
}

void Compare()
{
    double x = xe; double y = ye;
    while (true)
    {
        x += dx;
        y += dy;
  
        double tmp = Distance(x, y);
        if (tmp &gt; predistance)
            break;
        else
        {
            predistance = tmp;
            result_x = x;
            result_y = y;
        }
    }
}

void GCD()
{
    int small = min(dx, dy);
  
    if (small == 0)
    {
        if (dx == 0)
            dy = 1;
        else
            dx = 1;
        return;
    }
    while (small)
    {
        if (dx%small == 0 &amp;&amp; dy%small == 0)
            break;
        else
            small--;
    }

    if (small &gt; 1)
        dx /= small;
        dy /= small;
} 
int main()
{
    cin &gt;&gt; xs &gt;&gt; ys;
    cin &gt;&gt; xe &gt;&gt; ye &gt;&gt; dx &gt;&gt; dy;

    predistance = Distance(xe, ye);
    result_x = xe;
    result_y = ye;

    GCD();

    Compare();

    cout &lt;&lt; result_x &lt;&lt; " " &lt;&lt; result_y;
}
Run]]></description><link>공부\coding\백준풀이\(s1)1391-음하철도-구구팔.html</link><guid isPermaLink="false">공부/coding/백준풀이/(S1)1391 음하철도 구구팔.md</guid><pubDate>Thu, 13 Mar 2025 05:48:28 GMT</pubDate></item><item><title><![CDATA[(S3)14501 퇴사]]></title><description><![CDATA[ 
 <br><a rel="noopener nofollow" class="external-link" href="https://www.acmicpc.net/problem/14501" target="_blank">https://www.acmicpc.net/problem/14501</a><br><br>상담원으로 일하고 있는 백준이는 퇴사를 하려고 한다.<br>
오늘부터 N+1일째 되는 날 퇴사를 하기 위해서, 남은 N일 동안 최대한 많은 상담을 하려고 한다.<br>
백준이는 비서에게 최대한 많은 상담을 잡으라고 부탁을 했고, 비서는 하루에 하나씩 서로 다른 사람의 상담을 잡아놓았다.<br>
각각의 상담은 상담을 완료하는데 걸리는 기간 Ti와 상담을 했을 때 받을 수 있는 금액 Pi로 이루어져 있다.<br>
N = 7인 경우에 다음과 같은 상담 일정표를 보자.<br><br>1일에 잡혀있는 상담은 총 3일이 걸리며, 상담했을 때 받을 수 있는 금액은 10이다. 5일에 잡혀있는 상담은 총 2일이 걸리며, 받을 수 있는 금액은 15이다.<br>상담을 하는데 필요한 기간은 1일보다 클 수 있기 때문에, 모든 상담을 할 수는 없다. 예를 들어서 1일에 상담을 하게 되면, 2일, 3일에 있는 상담은 할 수 없게 된다. 2일에 있는 상담을 하게 되면, 3, 4, 5, 6일에 잡혀있는 상담은 할 수 없다.<br>또한, N+1일째에는 회사에&nbsp;없기 때문에, 6, 7일에 있는 상담을 할 수 없다.<br>퇴사 전에 할 수 있는 상담의 최대 이익은 1일, 4일, 5일에 있는 상담을 하는 것이며, 이때의 이익은 10+20+15=45이다.<br>상담을 적절히 했을 때, 백준이가 얻을 수 있는 최대 수익을 구하는 프로그램을 작성하시오.<br><br>첫째 줄에 N (1 ≤ N ≤ 15)이 주어진다.<br>둘째 줄부터 N개의 줄에 Ti와 Pi가 공백으로 구분되어서 주어지며, 1일부터 N일까지 순서대로 주어진다. (1 ≤ Ti&nbsp;≤ 5, 1 ≤ Pi&nbsp;≤&nbsp;1,000)<br><br>#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;algorithm&gt;

using namespace std;

int main() {
	int N;
	cin &gt;&gt; N;
	vector&lt;pair&lt;int, int&gt;&gt; arr(N+1);
	vector&lt;int&gt; dp(N+2, 0); 
	for (int i = 1; i &lt;= N; ++i)
		cin &gt;&gt; arr[i].first &gt;&gt; arr[i].second;
	for (int i = 1; i &lt;= N; ++i)
	{
		dp[i+1] = max(dp[i+1], dp[i]);
		if (i + arr[i].first &lt;= N + 1)
			dp[i + arr[i].first] = max(dp[i + arr[i].first], dp[i] + arr[i].second);
	}
	int max_profit = 0;
	for (int i = 1; i &lt;= N+1; ++i)
		max_profit = max(max_profit, dp[i]);
	cout &lt;&lt; max_profit &lt;&lt; endl;
	return 0;
}
Run<br>위의 코드는 1차원 dp로 푼 것입니다.<br>dp[i+1] = max(dp[i+1], dp[i])<br>
현재 날까지의 최대 수익을 다음 날로 넘깁니다<br>if (i + schedule[i].first &lt;= N + 1)<br>
일수가 초과되었는 지를 감지합니다.<br>입력<br>7
3 10
5 20
1 10
1 20
2 15
4 40
2 200
<br>에 대해서 다음과 같이 동작할 것입니다.<br>]]></description><link>공부\coding\백준풀이\(s3)14501-퇴사.html</link><guid isPermaLink="false">공부/coding/백준풀이/(S3)14501 퇴사.md</guid><pubDate>Thu, 13 Mar 2025 05:48:34 GMT</pubDate></item><item><title><![CDATA[백준풀이]]></title><description><![CDATA[ 
 <br><a data-tooltip-position="top" aria-label="https://cloudconvert.com/md-to-docx" rel="noopener nofollow" class="external-link" href="https://cloudconvert.com/md-to-docx" target="_blank">md to doc</a><br>
<a data-tooltip-position="top" aria-label="https://products.aspose.app/words/ko/conversion/md-to-doc#google_vignette" rel="noopener nofollow" class="external-link" href="https://products.aspose.app/words/ko/conversion/md-to-doc#google_vignette" target="_blank">md to doc2</a><br>
<br>미완<br>
<br><br>
<br>완료<br>
<br><br><br><br><br>
]]></description><link>공부\coding\백준풀이\백준풀이.html</link><guid isPermaLink="false">공부/coding/백준풀이/백준풀이.md</guid><pubDate>Thu, 13 Mar 2025 05:57:09 GMT</pubDate></item><item><title><![CDATA[입력]]></title><description><![CDATA[ 
 <br><br>입력의 첫 줄에는 원문에 출현할 수 있는 단어의 수 m (1  m  500)과 처리해야 할 문장의 수 q(1  q  100)가 주어집니다.<br>두 번째 줄에는 원문에 출현할 수 있는 m개의 단어가 공백으로 구분되어 주어집니다. 각 단어는 알파벳 대소문자로만 구성되어 있으며 길이는 10 이하입니다.<br>세 번째 줄에는 각 단어가 문장의 처음에 출현할 확률 가 m개의 실수로 주어집니다. 는 i번 단어가 첫 단어로 출현할 확률입니다. 모든 의 합은 1입니다.<br>그 후 m줄에  크기의 실수 행렬 T가 주어집니다. 이 행렬에서 i행 j열의 숫자 는 i번 단어의 다음 단어가 j번 단어일 확률을 나타냅니다. 각 행에 있는 확률의 합은 항상 1입니다.<br>그 후 m줄에  크기의 실수 행렬 M이 주어집니다. 이 행렬에서 i행 j열의 숫자 는 i번 단어가 적힌 조각을 j번 단어로 분류할 확률을 나타냅니다. 각 행에 있는 확률의 합은 항상 1입니다.<br>그 후 q줄에 한 줄에 하나씩 분류기로 인식한 문장이 주어집니다. 각 줄의 처음에 단어의 수 n(1 n 100)이 주어지고, 그 후 n개의 단어로 분류기의 인식 결과가 주어집니다. 모든 단어는 처음에 주어진 m개의 단어 중 하나입니다.<br>입력의 크기가 크므로 빠른 입력 방식을 사용하기를 권장합니다.<br><br>한 문장마다 한 줄에 주어진 인식 결과에 대해 조건부 출현 확률이 가장 높은 문장을 출력합니다. 주어지는 입력에서 가장 확률이 높은 문장이 여려 개인 경우 어느 것을 출력해도 좋습니다.<br><br>우선 예제 입력은 다음과 같습니다.<br>5 3 //5는 단어의 수, 3은 문장의 수
I am a boy buy //사용가능한 단어(5)
1.0 0.0 0.0 0.0 0.0 //문장의 첫 단어가 될 수 있는 확률
0.1 0.6 0.1 0.1 0.1
0.1 0.1 0.6 0.1 0.1
0.1 0.1 0.1 0.6 0.1
0.2 0.2 0.2 0.2 0.2  
0.2 0.2 0.2 0.2 0.2 //여기까지가 i의 다음 문장이 j일 확률
0.8 0.1 0.0 0.1 0.0
0.1 0.7 0.0 0.2 0.0
0.0 0.1 0.8 0.0 0.1
0.0 0.0 0.0 0.5 0.5
0.0 0.0 0.0 0.5 0.5 //여기까지가 i를 j로 잘못 인식할 경우
4 I am a buy
4 I I a boy
4 I am am boy //여기까지가 입력한 문장
<br>이에 따른 예제 출력은 다음과 같습니다.<br>I am a boy
I am a boy
I am a boy
<br>지금 주어진 정보는 원본 문장(I am a boy)를 변형된 문자(I I a boy)로 만들기 위한 정보가 주어진 것 과 같다.<br><br>이 문제는 단어 독립적으로 확률을 계산하기에 <a data-href="베이즈 정리" href="공부\수학\확률\베이즈-정리.html" class="internal-link" target="_self" rel="noopener nofollow">베이즈 정리</a>를 사용하여 풀 수 있는 문제이다.<br>우선 원본 문장을 Q, 변형 문장을 R로 가정한다.<br>
수식으로 나타내면 <a data-href="베이즈 정리" href="공부\수학\확률\베이즈-정리.html" class="internal-link" target="_self" rel="noopener nofollow">베이즈 정리</a>의 수식과 같다.<br><br>은 우리가 구하고자 하는 변형된 문장이 원본 문장과 같을 확률이다.<br>을 구하기 위해서는 와 와 을 구하면 된다.<br>우선 은 원문이 Q일 때, 분류기가 R을 반환할 확률이다.<br>
이 값에 대해서는  행렬 M이 원본 문자를 변형 문자로 잘못 인식하였을 확률이기에 행렬 M의 값을 사용하여 구할 수 있으며, 수식은 다음과 같다.<br><br>수식은 그저 가 로 분류될 확률을 곱한 것이다.<br>은 Q가 원문일 확률이며 Q가  <a data-href="마르코프 연쇄" href="공부\수학\확률\마르코프-연쇄.html" class="internal-link" target="_self" rel="noopener nofollow">마르코프 연쇄</a>에 따라 생성된다고 가정하고, 첫 번째 글자는 고정되어 있다고 가정할 시의 수식은 다음과 같다.<br><br>하지만 현실적으로 시작 단어를 알 방법이 없기에 가짜 단어를 에 만들어 이 단어가 항상 시작 단어라고 가정하는 것이다. 이 경우 이므로 에 대한 수식을 다음과 같이 정의할 수 있다.<br><br>과  모두 가 포함된 구조임을 알 수 있다. 따라서 하나의 식으로 만들면,<br><br>
 <br>마지막으로 해당 값을 로 나눠준다면, Q의 조건부 확률을 구할 수 있습니다.<br><br>확률 값을 계속 곱하면 언더플로우가 발생할 수 있기 때문에 log값을 취하여 곱해준다고 함]]></description><link>공부\coding\알고리즘-문제-해결-전략\광학-문자-인식.html</link><guid isPermaLink="false">공부/coding/알고리즘 문제 해결 전략/광학 문자 인식.md</guid><pubDate>Tue, 24 Dec 2024 12:12:14 GMT</pubDate></item><item><title><![CDATA[14번 문제]]></title><description><![CDATA[ 
 <br>A, B, C, D, E라는 5명의 선수가 100미터 달리기에 참가했습니다. 순위를 알기 위해서, 다음과 같은 형식의 질문을 할 수 있습니다. 참고로 동시에 도착하는 경우는 없다고 가정합니다.<br><br><br>
<br>3명의 선수를 선택하고, 그 중에서 누가 가장 먼저 들어왔는지 질문할 수 있습니다.
<br>3명의 선수를 선택하고, 그 중에서 누가 중간에 들어왔는지 질문할 수 있습니다.
<br>3명의 선수를 선택하고, 그 중에서 누가 마지막에 들어왔는지 질문할 수 있습니다.
<br>이때 다음과 같은 질문에 답해 주세요.<br>
<br>4번 이내의 질문으로는 모든 사람의 순위를 알 수 있는 방법이 없다는 것을 증명해 주세요.
<br>5번의 질문을 했을 때, 모든 사람의 순위를 맞히는 방법을 구성해 주세요.
<br>1번 질문에 대해서는 5명의 순위의 경우의 수는 일 것입니다. 문제에서 4번 이내의 질문을 하여 얻을수 있는 경우의 수는 입니다. 당연하게 (120)은 (81)보다 크기에 4번의 질문만으로는 모든 사람의 순위를 알 수 없습니다.<br>2번 질문에 대해서는 경우의 수를 줄이기 위해 가장 빠른 선수든, 가장 느린 선수를 찾아서 경우의 수에서 제거 하겠습니다.<br> 선수가 5이기에 이것을 구하는 것은 쉽습니다. A,B,C의 선수중 가장 빠른/느린 선수를 구하고, 그 선수를 포함하여 D,E 중 가장 빠른/느린 선수를 구한다면, 2번의 질문으로 경우의 수를 에서 으로 줄일 수 있게 됩니다.<br><br>의 경우의 수는 24가지이고, 의 경우의 수는 27가지이기에 모든 경우의 수에 대하여 질문이 가능하게 되어, 모든 선수의 순위에 대해 알 수 있게 됩니다.<br>코드 없이도 질문의 답을 제공하였지만, 이를 구현한 것은 다음과 같습니다.<br>#include &lt;bits/stdc++.h&gt;

using namespace std;

int arr[5];

int who_is_first(int a, int b, int c);
int who_is_middle(int a, int b, int c);
vector&lt;char&gt; remote(vector&lt;char&gt; unknown, char ch);
int main()
{
    int N, temp;
    
    vector&lt;char&gt; unknown;
    int guess1[10];
    char guess2[5];
    //A~E의 순위를 입력
    for(int i=0; i&lt;5; i++)
        cin&gt;&gt;arr[i];
    
    //1번 4번 이내의 질문으로는 모든 사람의 순위를 알 수 있는 지의 여부


    //2번 5번의 질문을 했을 때, 모든 사람의 순위를 맞히는 방법을 구성
    for(int i=0; i&lt;5; i++)
        unknown.push_back('A'+i);
    temp=who_is_first(0,1,2);               //질문 1. A,B,C중 가장 빠른 선수를 temp변수에 저장
    guess2[0]='A'+who_is_first(temp,3,4);   //질문 2. temp,D,E중 가장 빠른 선수가 1등이기에 guess[0]에 저장
    unknown=remote(unknown, guess2[0]);     //1등은 찾았기에 1등을 unknown에서 제거

    temp=who_is_first(unknown[0]-'A',unknown[1]-'A',unknown[2]-'A');  //질문 3. 남은 4개중 3개를 뽑아 1등을 조사
    if(temp==unknown[0]-'A')
    {
        temp=who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[3]-'A');  //질문 4. 3번의 정답과 이전에 선택하지 않은 항목과 임의의 한개중 중간값을 구함
        if(temp==unknown[0]-'A')
        {
            // 3번에 1등이 중간이라면, 이전에 선택하지 않았던 것이 1등, 3번의 1등이 중간, 나머지가 꼴등일 것임
            guess2[1]=unknown[3];
            guess2[2]=unknown[0];
            guess2[3]='A'+who_is_middle(unknown[1]-'A',unknown[2]-'A',unknown[3]-'A');
            unknown=remote(unknown, guess2[1]);
            unknown=remote(unknown, guess2[2]);
            unknown=remote(unknown, guess2[3]);
            guess2[4]=unknown[0];
            unknown=remote(unknown, guess2[4]);
        }
        else if(temp==unknown[1]-'A')
        {
            guess2[1]=unknown[0];
            unknown=remote(unknown, guess2[1]);
            guess2[3]=temp='A'+who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[2]-'A');
            if(temp==unknown[2])
            {
                guess2[2]=unknown[0];
                guess2[4]=unknown[1];
            }
            else if(temp==unknown[1])
            {
                guess2[2]=unknown[0];
                guess2[4]=unknown[2];
            }
            else if(temp==unknown[0])
            {
                guess2[2]=unknown[1];
                guess2[4]=unknown[2];
            }
        }
        else if(temp==unknown[3]-'A')
        {
            guess2[1]=unknown[0];
            unknown=remote(unknown, guess2[1]);
            guess2[3]=temp='A'+who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[2]-'A');
            if(temp==unknown[2])
            {
                guess2[2]=unknown[1];
                guess2[4]=unknown[0];
            }
            else if(temp==unknown[1])
            {
                guess2[2]=unknown[2];
                guess2[4]=unknown[0];
            }
            else if(temp==unknown[0])
            {
                guess2[2]=unknown[2];
                guess2[4]=unknown[1];
            }
        }
    }
    else if(temp==unknown[1]-'A')
    {
        temp=who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[3]-'A');  //질문 4. 3번의 정답과 이전에 선택하지 않은 항목과 임의의 한개중 중간값을 구함
        if(temp==unknown[1]-'A')
        {
            // 3번에 1등이 중간이라면, 이전에 선택하지 않았던 것이 1등, 3번의 1등이 중간, 나머지가 꼴등일 것임
            guess2[1]=unknown[3];
            guess2[2]=unknown[1];
            guess2[3]='A'+who_is_middle(unknown[0]-'A',unknown[2]-'A',unknown[3]-'A');
            unknown=remote(unknown, guess2[1]);
            unknown=remote(unknown, guess2[2]);
            unknown=remote(unknown, guess2[3]);
            guess2[4]=unknown[0];
            unknown=remote(unknown, guess2[4]);
        }
        else if(temp==unknown[0]-'A')
        {
            guess2[1]=unknown[1];
            unknown=remote(unknown, guess2[1]);
            guess2[3]=temp='A'+who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[2]-'A');
            if(temp==unknown[2])
            {
                guess2[2]=unknown[0];
                guess2[4]=unknown[1];
            }
            else if(temp==unknown[1])
            {
                guess2[2]=unknown[0];
                guess2[4]=unknown[2];
            }
            else if(temp==unknown[0])
            {
                guess2[2]=unknown[1];
                guess2[4]=unknown[2];
            }
        }
        else if(temp==unknown[3]-'A')
        {
            guess2[1]=unknown[1];
            unknown=remote(unknown, guess2[1]);
            guess2[3]=temp='A'+who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[2]-'A');
            if(temp==unknown[2])
            {
                guess2[2]=unknown[1];
                guess2[4]=unknown[0];
            }
            else if(temp==unknown[1])
            {
                guess2[2]=unknown[2];
                guess2[4]=unknown[0];
            }
            else if(temp==unknown[0])
            {
                guess2[2]=unknown[2];
                guess2[4]=unknown[1];
            }
        }
    }
    else if(temp==unknown[2]-'A')
    {
        temp=who_is_middle(unknown[1]-'A',unknown[2]-'A',unknown[3]-'A');  //질문 4. 3번의 정답과 이전에 선택하지 않은 항목과 임의의 한개중 중간값을 구함
        if(temp==unknown[2]-'A')
        {
            // 3번에 1등이 중간이라면, 이전에 선택하지 않았던 것이 1등, 3번의 1등이 중간, 나머지가 꼴등일 것임
            guess2[1]=unknown[3];
            guess2[2]=unknown[2];
            guess2[3]='A'+who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[3]-'A');
            unknown=remote(unknown, guess2[1]);
            unknown=remote(unknown, guess2[2]);
            unknown=remote(unknown, guess2[3]);
            guess2[4]=unknown[0];
            unknown=remote(unknown, guess2[4]);
        }
        else if(temp==unknown[1]-'A')
        {
            guess2[1]=unknown[2];
            unknown=remote(unknown, guess2[1]);
            guess2[3]=temp='A'+who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[2]-'A');
            if(temp==unknown[2])
            {
                guess2[2]=unknown[0];
                guess2[4]=unknown[1];
            }
            else if(temp==unknown[1])
            {
                guess2[2]=unknown[0];
                guess2[4]=unknown[2];
            }
            else if(temp==unknown[0])
            {
                guess2[2]=unknown[1];
                guess2[4]=unknown[0];
            }
        }
        else if(temp==unknown[3]-'A')
        {
            guess2[1]=unknown[2];
            unknown=remote(unknown, guess2[1]);
            guess2[3]=temp='A'+who_is_middle(unknown[0]-'A',unknown[1]-'A',unknown[2]-'A');
            if(temp==unknown[2])
            {
                guess2[2]=unknown[1];
                guess2[4]=unknown[0];
            }
            else if(temp==unknown[1])
            {
                guess2[2]=unknown[2];
                guess2[4]=unknown[0];
            }
            else if(temp==unknown[0])
            {
                guess2[2]=unknown[2];
                guess2[4]=unknown[1];
            }
        }
    }
    cout&lt;&lt;"입력값 : ";
        for(int i=0; i&lt;5;i++)
            cout&lt;&lt;(char)('A'+arr[i]-1)&lt;&lt;" ";
        cout&lt;&lt;endl;
        cout&lt;&lt;"추론값 : ";
        for(int i=0; i&lt;5;i++)
            cout&lt;&lt;guess2[i]&lt;&lt;" ";
    return 0;
}

/*
    ((arr[0]&gt;arr[1])?arr[1]:arr[0])&gt;arr[2]?arr[2]:((arr[0]&gt;arr[1])?arr[1]:arr[0])
    삼항 연산자를 활용한, 셋 중 가장 빠른 선수 찾는 코드
*/ 
int who_is_first(int a, int b, int c)
{
    return ((arr[a]&gt;arr[b])?b:a)&gt;arr[c]?c:((a&gt;b)?b:a);
}
int who_is_middle(int a, int b, int c) 
{
    return ((arr[a] &gt; arr[b]) ? ((arr[b] &gt; arr[c]) ? b : ((arr[a] &gt; arr[c]) ? c : a)) : ((arr[a] &gt; arr[c]) ? a : ((arr[b] &gt; arr[c]) ? c : b)));
}

vector&lt;char&gt; remote(vector&lt;char&gt; unknown, char ch)
{
    unknown.erase(remove_if(unknown.begin(), unknown.end(), [ch](char num) {
        return ch == num;
    }), unknown.end());
    return unknown;
}
Run<br><img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/1c65b32f-df86-40b0-af44-3424f4dbfcb6" referrerpolicy="no-referrer"><br>
<img alt="image" src="https://github.com/bloodmoon3929/Algorithm/assets/144004857/1a3019ba-f276-4d7c-bbd4-9055a4b16a27" referrerpolicy="no-referrer">]]></description><link>공부\coding\알고리즘with수학\14번-문제.html</link><guid isPermaLink="false">공부/coding/알고리즘with수학/14번 문제.md</guid><pubDate>Thu, 13 Mar 2025 07:32:14 GMT</pubDate><enclosure url="https://github.com/bloodmoon3929/Algorithm/assets/144004857/1c65b32f-df86-40b0-af44-3424f4dbfcb6" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;https://github.com/bloodmoon3929/Algorithm/assets/144004857/1c65b32f-df86-40b0-af44-3424f4dbfcb6&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[27번 문제]]></title><description><![CDATA[ 
 <br>N개의 공이 있고, 각각의 공에는 1부터 N까지의 정수가 적혀있습니다. 정수 N이 주어질 때, 에 대해서 다음과 같은 질문에 답하는 프로그램을 작성해 주세요.<br>
<br>N개의 공에서 1개 이상의 공을 선택하는 방법은 가지 존재합니다. 이 중에서 다음과 같은 조건을 만족하는 선택 방법이 몇 가지 있는지를 1000000007로 나눈 나머지를 구해 주세요.
<br>조건 : 어떤 2개의 공을 선택해도 적혀있는 정수의 차가  이상이어야 합니다.
<br>을 만족하는 입력에서 2초 이내에 답을 구하게 구성해 주세요(출전 : 競プロ典型 90 問015 - Don't be too close).<br>제약<br><br>
<br><br>
<br>N은 정수입니다.
<br>실행 시간 제한<br>
<br>2초
<br>입력<br>
<br>N
<br>출력<br>
<br>N줄 출력합니다. i()번째 줄에는 일 때의 답을 로 나눈 나머지를 출력해 주세요.
<br>입력 예1<br>1
<br>출력 예1<br>1
<br>입력 예2<br>2
<br>출력 예2<br>3
2
<br>입력 예3<br>20
<br>출력 예3<br>1048575
17710
2744
906
430
250
167
118
90
75
65
56
48
41
35
30
26
23
21
20
<br><br>i번째 줄에 각 수가 i만큼 차이가 나야 한다면, 전체 집합으로 풀지 않고, i개의 집합들의 조합으로 풀면 될 것입니다.<br>20개에서 1개를 뽑을 확률 의 답인 20부터, 까지의 답을 구했음<br>20+190+1140+4845+15504+38760+77520+125970+167960+184756+167960+125970+77520+38760+15504+4845+1140+190+20+1의 결과값이 입력값이 20일때의 첫째 줄 츨력값과 동일함을 알 수 있었음<br><br><br> 가 성립합니다.<br><br>#include &lt;iostream&gt;
using namespace std;

const int MOD = 1000000007;

long long power(long long x, long long y) 
{
    long long result = 1;
    while (y &gt; 0) 
    {
        if (y % 2 == 1)
            result = (result * x) % MOD;
        x = (x * x) % MOD;
        y /= 2;
    }
    return result;
}

long long combination(int N, int K) {
    long long result = 1;
    for (int i = 0; i &lt; K; ++i) {
        result = (result * (N - i)) % MOD;
        result = (result * power(i + 1, MOD - 2)) % MOD;
    }
    return result;
}

int main() {
    int N;
    cin &gt;&gt; N;

    for (int k = 1; k &lt;= N; ++k) {
        long long result = 0;

        for (int m = 1; m &lt;= N; ++m) 
        {
            int M = N - (m - 1) * (k - 1);
            if (M&lt;= 0)
                break;
            long long ways = combination(M, m);
            result = (result + ways) % MOD;
        }

        cout &lt;&lt; result &lt;&lt; endl;
    }

    return 0;
}

Run<br><br>나눗셈 모듈러 연산(<a data-href="모듈러 역수" href="공부\수학\모듈러-역수.html" class="internal-link" target="_self" rel="noopener nofollow">모듈러 역수</a>)을 위해 역원을 찾기위해 사용하였습니다.<br><br>조합을 수행하기 위해 만들었습니다.<br><br>1번째 줄부터 N번째 줄까지 반복하여 출력해야 함으로 1~N까지 반복하는 for문으로 만들어 졌습니다.<br><br><br>우선 (m-1) * (k-1) 부분의 경우 공들의 최소 간격을 나타냅니다.<br>m은 선택할 공의 갯수, k는 선택한 공의 차이를 나타냅니다.<br>N이 10이고, k와 m이 3이라고 가정했을 때,<br><br>다음과 같이 나타낼 수 있습니다.<br>()는 k를 보기 좋게 형상화 항 것입니다. k만큼 차이가 나야 하기에 괄호 안의 것끼리는 동시에 고를 수 없습니다. 그러기에 각 그룹내의 원소간의 거리는 (k - 1)<br>m은 선택할 그룹의 갯수입니다. 각 그룹간의 거리는 (m - 1)<br>그러기에 이 둘을 곱하고, 전체 공의 갯수인 N에 해당 값을 빼줌으로써 남아있는 공의 양을 찾을 수 있습니다.<br><br>위의 값이 음수일 경우 동작하면 안됨으로 해당 조건을 달았습니다.<br>
음수일시, 남아있는 공은 존재하지 않으므로 동작하면 안됩니다.]]></description><link>공부\coding\알고리즘with수학\27번-문제.html</link><guid isPermaLink="false">공부/coding/알고리즘with수학/27번 문제.md</guid><pubDate>Thu, 13 Mar 2025 07:34:15 GMT</pubDate></item><item><title><![CDATA[눈 시뮬레이션]]></title><description><![CDATA[ 
 <br>이 문제는 계차(<a data-href="계차와 누적합" href="공부\수학\계산-기하학\계차와-누적합.html" class="internal-link" target="_self" rel="noopener nofollow">계차와 누적합</a>)를 이용하여 푸는 문제입니다.<br><br>
n일 부터 m일까지 k만큼의 눈이 내렸다면 계차 배열에는 n번 항에 k를 더하고 m-1항에 k를 빼주면 됩니다. 이렇게 모두 기록하고 난 후 1번부터 m번까지가(0번 제외) 구하고자한 값이고 비교 연산자를 사용해 출력만 해주면 됩니다.<br><br>
이 역시 시간 복잡도는 O(N+Q)입니다. <br>#include&lt;iostream&gt;
#include&lt;vector&gt;

using namespace std;
int main()
{
    int N,Q,X,Y,Z;
    cin&gt;&gt;N&gt;&gt;Q;
    vector&lt;int&gt; sum(N+2);
    for(int i=0; i&lt;Q; i++)
    {
        cin&gt;&gt;X&gt;&gt;Y&gt;&gt;Z;
        sum[X]+=Z;
        sum[Y+1]-=Z;
    }
    for(int i=2; i&lt;N+1; i++)
    {
        if(sum[i]&gt;0)
        {
            cout&lt;&lt;"&lt;";
        }
        else if(sum[i]==0)
        {
            cout&lt;&lt;"=";
        }
        else if(sum[i]&lt;0)
        {
            cout&lt;&lt;"&gt;";
        }
    }
    return 0;
}
Run]]></description><link>공부\coding\알고리즘with수학\눈-시뮬레이션.html</link><guid isPermaLink="false">공부/coding/알고리즘with수학/눈 시뮬레이션.md</guid><pubDate>Thu, 13 Mar 2025 07:34:42 GMT</pubDate></item><item><title><![CDATA[입장 인원 계산하기]]></title><description><![CDATA[ 
 <br>이 문제는 누적합(<a data-href="계차와 누적합" href="공부\수학\계산-기하학\계차와-누적합.html" class="internal-link" target="_self" rel="noopener nofollow">계차와 누적합</a>)을 이용하여 푸는 문제입니다.<br><br>
2번 줄에 기록된 배열의 누접합을 구하고, n부터 m까지 구한다고 가정했을시<br><br>
누접합 배열의 을 구한다면 O(NQ)가 아닌 O(N+Q)의 시간복잡도로 이 문제를 풀 수 있습니다.<br>#include&lt;iostream&gt;
#include&lt;vector&gt;

using namespace std;
int main()
{
    int N,Q,X,Y;
    cin&gt;&gt;N&gt;&gt;Q;
    vector&lt;int&gt; sum;
    cin&gt;&gt;X;
    sum.push_back(X);
    for(int i=1; i&lt;N; i++)
    {
        cin&gt;&gt;X;
        sum.push_back(X+sum[i-1]);
    }
    vector&lt;pair&lt;int,int&gt;&gt; input;
    for(int i=0; i&lt;Q; i++)
    {
        cin&gt;&gt;X&gt;&gt;Y;
        input.push_back(make_pair(X-1,Y-1));
    }
    for(int i=0; i&lt;Q; i++)
    {
        if(input[i].first==0)
        {
            cout&lt;&lt;sum[input[i].second]&lt;&lt;endl;
        }
        else
        {
            cout&lt;&lt;sum[input[i].second]-sum[input[i].first-1]&lt;&lt;endl;
        }
    }
    return 0;
}
Run]]></description><link>공부\coding\알고리즘with수학\입장-인원-계산하기.html</link><guid isPermaLink="false">공부/coding/알고리즘with수학/입장 인원 계산하기.md</guid><pubDate>Thu, 13 Mar 2025 07:34:56 GMT</pubDate></item><item><title><![CDATA[점과 선분의 거리]]></title><description><![CDATA[ 
 <br>이 문제를 풀기 위해서는 3가지 패턴이 나온다는 것을 알아야 합니다.<br>
<br>각 ABC가 90도 초과 
<br>각 ACB가 90도 초과
<br>각 ABC와 ACB가 90도 이하 
<br>1번과 2번의 경우는 고민할것도 없이 A와 B사이의 거리, A와 C사이의 거리가 최단 경로일 것입니다.<br><br>
하지만 3번의 경우는 선분 와 수직을 이루는 지점이 최단경로일 것입니다.<br><br><br>
이를 구하기 위한 공식은 다음과 같습니다.<br>
<br><a data-href="벡터" href="공부\수학\계산-기하학\벡터.html" class="internal-link" target="_self" rel="noopener nofollow">벡터</a> 와 의 외적을 구합니다.(평행 사변형의 면적을 구하기 위해)
<br>평행사변형 면적을 구하는 공식은 임으로 구한 외적에 밑변인 를 나누어 높이를 구합니다.
<br>이를 구현한 코드는 다음과 같습니다.<br>#include&lt;iostream&gt;
#include&lt;cmath&gt;
#include&lt;iomanip&gt;

using namespace std;

int main()
{
    int arr[2][3];
    int pattern=2;
    int vecter[2][4];
    for(int i=0; i&lt;3; i++)
    {
        for(int j=0; j&lt;2; j++)
        {
            cin&gt;&gt;arr[j][i];
        }
    }
   
    vecter[0][0]=arr[0][0]-arr[0][1];
    vecter[1][0]=arr[1][0]-arr[1][1];

    vecter[0][1]=arr[0][2]-arr[0][1];
    vecter[1][1]=arr[1][2]-arr[1][1];

    vecter[0][2]=arr[0][0]-arr[0][2];
    vecter[1][2]=arr[1][0]-arr[1][2];
    
    vecter[0][3]=arr[0][1]-arr[0][2];
    vecter[1][3]=arr[1][1]-arr[1][2];

    if(vecter[0][0]*vecter[0][1]+vecter[1][0]*vecter[1][1]&lt;0)
        pattern=1;
    else if(vecter[0][2]*vecter[0][3]+vecter[1][2]*vecter[1][3]&lt;0)
        pattern=3;

    if(pattern==1)
        cout&lt;&lt;setprecision(13)&lt;&lt;sqrt(pow(vecter[0][0],2)+pow(vecter[1][0],2));
    else if(pattern==2)
    {
       cout&lt;&lt;setprecision(13)&lt;&lt;abs(vecter[0][0]*vecter[1][1]-vecter[1][0]*vecter[0][1])/sqrt(pow(vecter[0][1],2)+pow(vecter[1][1],2));
    }
    else if(pattern==3)
        cout&lt;&lt;setprecision(13)&lt;&lt;sqrt(pow(vecter[0][2],2)+pow(vecter[1][2],2));
    return 0;
}
Run<br>arr 배열에 입력된 값은 책 기준 다음과 같습니다.<br><br><br><br><br>
vecter 배열에 입력된 값은 책 기준 다음과 같습니다.<br><br><br><br><br>
pattern은 다음과 같음을 나타냅니다<br>
<br>ABC의 각이 90가 초과했을시()
<br>패턴 1, 3 둘다 아닐시
<br>ACB의 각이 90가 초과했을시()<br>
<br>
<br><br>입출력 조작과 관련된 도구를 제공하는 헤더파일<br><br>
setprecision()을 사용하기 위해 사용하였고, 해당 메서드는 출력할 소수점의 몇번째 자리까지 출력할지 결정하는 메서드]]></description><link>공부\coding\알고리즘with수학\점과-선분의-거리.html</link><guid isPermaLink="false">공부/coding/알고리즘with수학/점과 선분의 거리.md</guid><pubDate>Thu, 13 Mar 2025 07:36:03 GMT</pubDate></item><item><title><![CDATA[피보나치 수열의 나머지]]></title><description><![CDATA[ 
 <br>#include&lt;iostream&gt;
#define MOD 1000000007

using namespace std;

int main()
{
    int N,pre=1,cur=1,temp;
    cin&gt;&gt;N;
    for(int i=2; i&lt;N; i++)
    {
        temp=(pre+cur)%MOD;
        pre=cur;
        cur=temp;
    }
    if(N&lt;=2)
        cout&lt;&lt;"1";    
    else
        cout&lt;&lt;temp%MOD;
    return 0;
}
Run<br>책에서 요구한 8691200번째의 피보나치 수열은 자리수만 209자리임으로 int 자료형으로는 절대 풀 수 없으나, <a data-href="모듈러 역수" href="공부\수학\모듈러-역수.html" class="internal-link" target="_self" rel="noopener nofollow">모듈러 역수</a>를 알고있다면 구할 수 있습니다.]]></description><link>공부\coding\알고리즘with수학\피보나치-수열의-나머지.html</link><guid isPermaLink="false">공부/coding/알고리즘with수학/피보나치 수열의 나머지.md</guid><pubDate>Thu, 13 Mar 2025 07:36:14 GMT</pubDate></item><item><title><![CDATA[a의 b 제곱과 나머지]]></title><description><![CDATA[ 
 <br>#include&lt;iostream&gt;
#include&lt;queue&gt;

#define MOD 1000000007

using namespace std;

int main()
{
    long long int N,M,temp=1;
    cin&gt;&gt;N&gt;&gt;M;
    queue&lt;int&gt; binary;
    while(M&gt;0)
    {
        binary.push(M%2);
        M/=2;
    }
    while(!binary.empty())
    {
        int bit =binary.front();
        binary.pop();
        if(bit==1)
        {
            temp*=(N%MOD);
        }
        N*=N;
    }
    cout&lt;&lt;temp%MOD;
    return 0;
}
Run<br>승수의 경우 을 구하는 방식을 로 푸는 것이 메모리도 덜 차지하기에 승수를 2진수화 한 뒤 그 값에 따라 곱하여 주었습니다. <br><a data-href="모듈러 역수" href="공부\수학\모듈러-역수.html" class="internal-link" target="_self" rel="noopener nofollow">모듈러 역수</a>]]></description><link>공부\coding\알고리즘with수학\a의-b-제곱과-나머지.html</link><guid isPermaLink="false">공부/coding/알고리즘with수학/a의 b 제곱과 나머지.md</guid><pubDate>Thu, 13 Mar 2025 07:36:28 GMT</pubDate></item><item><title><![CDATA[외톨이 알파벳]]></title><description><![CDATA[ 
 <br>#include &lt;bits/stdc++.h&gt;

using namespace std;

string solution(string input_string)
{
    string answer = "";
    vector&lt;int&gt; first(26, -1);
    vector&lt;bool&gt; continuous(26, true);
    vector&lt;int&gt; count(26, 0);

    for(int i = 0; i &lt; input_string.length(); i++)
    {
        int idx = input_string[i] - 'a';
        count[idx]++;
        if(first[idx] == -1)
            first[idx] = i;
    }

    for(int i = 1; i &lt; input_string.length(); i++)
    {
        int curr_idx = input_string[i] - 'a';
        int prev_idx = input_string[i-1] - 'a';
        if(curr_idx != prev_idx)
            if(first[curr_idx] != i &amp;&amp; first[curr_idx] != -1)
                continuous[curr_idx] = false;
    }

    set&lt;char&gt; lonely_chars;

    for(int i = 0; i &lt; 26; i++)
        if(count[i] &gt;= 2 &amp;&amp; !continuous[i])
            lonely_chars.insert('a' + i);

    for(char c : lonely_chars)
        answer += c;

    return answer.empty() ? "N" : answer;
}
Run<br>first = 처음 알파벳이 나오는 위치 기록<br>
continuous = 알파벳이 연속적으로 나오는지 기록<br>
count = 나온 갯수 기록<br>for문이 4개 존재함<br>1번 for문<br>
알파벳이 처음 나오는 위치 기록<br>2번 for문<br>
현재 글자와 이전 글자가 다르고,<br>
현재 위치가 문자의 처음 나오는 위치가 아니며<br>
문자가 이전에 나온적이 있다면<br>문자는 연속되지 않았음<br>3번 for문<br>
2번 이상 나왔으며 연속되지 않았을 때, set에 추가하여 정렬<br>4번 for문<br>
연속되지 않는 문자를 정답 문자열에 추가]]></description><link>공부\coding\pccp\외톨이-알파벳.html</link><guid isPermaLink="false">공부/coding/PCCP/외톨이 알파벳.md</guid><pubDate>Thu, 13 Mar 2025 07:36:56 GMT</pubDate></item><item><title><![CDATA[체육대회]]></title><description><![CDATA[ 
 <br>#include &lt;bits/stdc++.h&gt;

using namespace std;

vector&lt;int&gt; choose;
vector&lt;int&gt; used;
int sport;
int student;
int total=-1;

void back(int cnt, vector&lt;vector&lt;int&gt;&gt; &amp;ability)
{
    if(cnt==sport)
    {
        int sum=0;
        for(int i=0;i&lt;cnt;i++)
            sum+=ability[choose[i]][i];
        total=max(total, sum);
        return;
    }
    for(int i=0;i&lt;student;i++)
    {
        if(!used[i])
        {
            used[i]=true;
            choose[cnt]=i;
            back(cnt+1, ability);
            used[i]=false;
        }
    }
}
int solution(vector&lt;vector&lt;int&gt;&gt; ability) 
{
    sport=ability[0].size();
    student=ability.size();
    
    choose.assign(sport, 0);
    used.assign(student, 0);

    back(0, ability);

    return total;
}
Run<br>backtracking을 통해 전수조사함<br>choose = 선택된 학생이 어떤<br>
used = 해당 학생이 사용되었는지 여부<br>
sport = 과목의 수<br>
student = 학생의 수<br>
total = 가장 값이 큰 값<br>종료 조건<br>
<br>
if(cnt == sport)<br>
현재 값이 과목수와 같을 때

<br>
for(int i=0;i&lt;cnt;i++) sum+=ability[choose[i]][i];<br>
학생별로 어떤 과목을 선택하였는지를 찾아서 sum에 추가

<br>
total=max(total, sum);<br>
최댓값을 최신화함

<br>
if(!used[i])<br>
해당 학생이 이전에 선택되지 않았을 때

<br>
used[i]=true; , used[i]=false;<br>
학생을 선택하고, 선택을 취소함

<br>
choose[cnt]=i;<br>
cnt는 과목을 뜻하고, 해당 과목은 i학생이 선택했다는 것을 뜻함

<br>
back(cnt+1, ability);<br>
다음 과목을 선택

]]></description><link>공부\coding\pccp\체육대회.html</link><guid isPermaLink="false">공부/coding/PCCP/체육대회.md</guid><pubDate>Thu, 13 Mar 2025 07:37:17 GMT</pubDate></item><item><title><![CDATA[TensorFlow 가 무엇인가]]></title><description><![CDATA[ 
 <br><br><br>
<br>Python, C++, Java, R, Go등의 언어를 지원함
<br>고급 신경망 API
<br>정적 그래프에 기반한 그래프연산과 함께 즉시 연산 지원이 도입됨
<br><br>딥러닝 모델을 만들고 훈련시키기 위한 기초 구성 요소를 구성하는 API<br><br>인공 신경망(Artificial neural networks;ANN)은 포유류의 중추 신경계 연구에서 영감을 받은 머신러닝 모델이다.<br>
결국 머신러닝은 여러 겹으로 이루어진 덧셈과 곱셈연산에 지나지 않으나, 비선형 활성화와 결합하여 여러겹을 쌓을 시에는 모든 값을 학습시킬 수 있을 것이다.<br><br>n개의 크기를 갖는 입력 벡터가 주어지면 true, false를 반환하는 간단한 알고리즘<br>수식으로 나타내면 다음과 같다<br><br>퍼셉트론은 오로지 true, false 만을 반환할 수 있다는 것을 상기하자<br><br>단일 선형 계층 모델인 퍼셉트론이 여러 계층 존재할 시의 이름임<br>사용자는 입력과 출력만을 볼 수 있고, 중간계층은 은닉층(hidden layers)라는 이름으로 불리며 숨겨져 있다<br><br>퍼셉트론은 오로지 0과 1의 큰 변화만 가능하기에 학습에 도움이 되지 않는다.<br>이것을 해결하기 위해 점진적으로 변화하는 함수가 필요하다.(미분 가능한 연속함수)<br><br>활성화 함수는 점진적으로 변화하는 함수이며, 퍼셉트론처럼 0, 1만의 대답만을 하는 것이 아닌 그 중간값의 대답을 할 수 있기에 신경망의 오류는 조금씩 줄이며 적응해 나아가는 학습 알고리즘을 개발 할 수 있음<br>
<a data-tooltip-position="top" aria-label="https://www.geogebra.org/graphing/xr3nzzsw" rel="noopener nofollow" class="external-link" href="https://www.geogebra.org/graphing/xr3nzzsw" target="_blank">활성화 함수 그래프</a><br><br><br>입력이 에서 변할 때, 출력은 (0,1)에서 작은 변화를 가진다.<br>
<img alt="Pasted image 20240702202221.png" src="lib\media\pasted-image-20240702202221.png"><br><br><br>입력이 에서 변할 때, 출력은 (-1,1)에서 변화를 가진다.<br>
<img alt="Pasted image 20240702212625.png" src="lib\media\pasted-image-20240702212625.png"><br><br><br>입력이 에서 변할 때, 출력은 에서 변화를 가진다.<br>
<img alt="Pasted image 20240702213552.png" src="lib\media\pasted-image-20240702213552.png"><br><br><br><br>입력이 에서 변할 때, 출력은 값에 따라 변화를 가진다. ()일 때,<br>
<img alt="Pasted image 20240702213625.png" src="lib\media\pasted-image-20240702213625.png"><br><br><br>입력이 에서 변할 때, 출력은 값에 따라 변화를 가진다.<br>
<img alt="Pasted image 20240702213719.png" src="lib\media\pasted-image-20240702213719.png"><br><br>이미 정답이 존재하는 지도 학습임<br><br>신경망 내부에 사용될 정보를 인코딩하는 간단한 도구<br>범주형 특징을 숫자형 변수로 변환하면 좋을 때 사용한다.<br>학습 알고리즘이 수치형 함수를 처리하도록 특화될 경우 데이터 마이닝에서 흔히 사용된다.]]></description><link>공부\coding\tensorflow-딥러닝\1장-tf와-신경망-기초.html</link><guid isPermaLink="false">공부/coding/tensorflow 딥러닝/1장 TF와 신경망 기초.md</guid><pubDate>Thu, 04 Jul 2024 07:06:59 GMT</pubDate><enclosure url="lib\media\pasted-image-20240702202221.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240702202221.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[2장 회귀와 분류]]></title><description><![CDATA[ 
 <br>
<br>회귀 : 주어진 종속변수와 독립변수 사이의 관계를 학습해 데이터를 예측할 수 있게 해주는 알고리즘; 둘 이상의 관계를 찾는 모든 곳에서 회귀를 사용할 수 있다.
<br>
<br>독립 변수 : 다른 변수에 의해 변하지 않는 변수
<br>종속 변수 : 독립변수에 의해 값이 결정되는 변수
<br>ex) 치킨 값(종속 변수) = 재료비 + 인테리어비 + 프렌차이즈비 + etc(독립 변수)<br>머신러닝에서는 입력으로 독립 변수를, 출력으로는 종속 변수를 갖는다.<br>
독립 변수의 수, 종속 변수의 수, 관계, 영향 강도에 따라 각기 다른 회귀 방법을 선택한다.<br><br>선형회귀는 입력 변수와 출력 변수 사이에 선형의 관계가 있다고 가정하고, 출력 변수의 예측 값에 대한 선형 방정식을 찾는 과정이 포함된다.<br>에측 값이 선형으로 나타난다는 가정을 하였을 때, 다음과 같은 방정식을 세울 수 있다.<br>  (단순 선형회귀)<br><br>
<br>
X는 입력 변수 이며, 이 방정식은 단순 선형회귀이기에 X의 값이 하나로 그려 졌지만, 그 수는 자유롭게 늘릴 수 있다.

<br>
W는 선형 계수 이며, 각 입력 변수 X에 대해 1대1 대응하는 관계이다.

<br>
b는 편향이다.

<br>입력 변수와 선형 계수가 n개 있다고 가정할 시 다음과 같은 방정식으로 그릴 수 있을 것이다.<br><br>오차 값은 실제 값에 예측 값과의 차이이기에 두 값을 뺀 값임을 알 수 있다.<br><br><br>일단 입력 변수를 A로 가정하고 다시 수식을 작성해 보면<br><br>구하고자 하는 값은 최대한 오차의 크기가 작은 선형 방정식을 구하려 하기에 선형대수학의 최소 제곱법을 사용할 것입니다.<br>우선 오차의 제곱이 합을 최소로 하기 위해 다음의 방정식을 작성합니다.<br><br>식을 보면 오차 값인 의 제곱 값의 합들을 구하는 방정식임을 알 수 있습니다.<br>그리고 예측값은 이기에 대입하여 방정식을 구합니다.<br>최소 제곱합이 0이 되는 지점은 W와 b에 대한 S의 편미분 계수가 0이 되는 지점이라는 것을 활용하여<br><br><br>라는 두 개의 방정식을 구할 수 있습니다.<br>그 중  방정식을 풀어 쓰면<br><br>이란 수식을 얻을 수 있고, b에 대해서 b를 N번 더하는 수식이기에 Nb로 치환 할 수 있습니다.<br><br>이 식을 b에 대해 다시 쓰면<br><br>두 시그마는 평균 출력 값과 평균 입력 값으로 대체 할 수 있습니다. 그 방정식은<br><br>이고, 이것이 편항을 구하는 방정식 입니다.<br>가중치를 구하는 방정식은 을 통하여 구할 것 이며 확장된 식은 다음과 같을 것 입니다.<br><br>편향치 b는 구하였기에 이를 치환하면<br><br>라는 수식이 되고 가중치를 기준으로 분리하면<br><br>이 되고 평균의 정의를 통해 W는<br><br>이 됩니다.<br>사용된 평균의 정의 평균-i번째 값= 편<br>행렬로도 풀 수 있습니다.<br>
<a data-tooltip-position="top" aria-label="https://subprofessor.tistory.com/104" rel="noopener nofollow" class="external-link" href="https://subprofessor.tistory.com/104" target="_blank">최소제곱선</a><br><br><img alt="code1 1.png" src="lib\media\code1-1.png"><br><img alt="code2 1.png" src="lib\media\code2-1.png"><br>
이 코드에서 area가 입력 변수 이며, price가 출력 변수이다.<br><img alt="output 1.png" src="lib\media\output-1.png"><br><img alt="code3 1.png" src="lib\media\code3-1.png"><br>
위해서 구한 수식을 통해 W와 b를 구한다.<br><img alt="code4 1.png" src="lib\media\code4-1.png"><br>
구한 W와 b가 있기에 특정한 부분에서의 예측 값을 구할 수 있다.<br><img alt="code5 1.png" src="lib\media\code5-1.png"><br>
실제 비교한 결과 예측 값과 거의 유사한 값들로 이루어 진 것을 알 수 있다.<br><img alt="output2.png" src="lib\media\output2.png"><br>다중 선형회귀 : 다량의 독립 변수에 의해 종속 변수가 결정되는 것<br>
ex) 짜장면 가격(종속 변수) = 재료비, 인테리어비 등등(독립 변수)<br>다변량 선형회귀 : 한 개의 독립 변수가 두 개 이상의 종속 변수에 영향을 끼치는 것<br>
ex) 짜장면 가격(종속 변수) = 재료비, 인테리어비 등등(독립 변수)<br>
짬뽕 가격(종속 변수) = 재료비, 인테리어비 등등(독립 변수)<br>두 코드는 대체로 단순 선형회귀 수식과 대부분 일치하기에 수식은 스킵함<br><br>단순 퍼셉트론의 수식은 다음과 같다.<br><br>단순 선형회귀의 경우 수식으로 계산이 가능하기에 은닉층이 필요하지 않다<br><img alt="code_1.png" src="lib\media\code_1.png"><br><img alt="code_2.png" src="lib\media\code_2.png"><br><img alt="output 1.png" src="lib\media\output-1.png"><br><img alt="code_3.png" src="lib\media\code_3.png"><br>데이터를 정규화하는 과정, 연산과정에서 입력 값이 가중치로 곱해지기에 큰 수를 사용할 수 없기에 데이터의 범위를 줄이는 과정<br><img alt="code_4.png" src="lib\media\code_4.png"><br>
<br>
Sequential 모델<br>
순차적으로 레이어를 쌓을 수 있는 모델을 정의할 때 사용됨. 모델은 각 레이어가 순서대로 연결된 단순한 스택 구조를 가짐.

<br>
Dense 레이어<br>
완전 연결 계층(Fully Connected Layer)으로, 입력 노드와 출력 노드가 모두 연결된 형태.

<br>
<br>Dense(1): 하나의 뉴런(출력 노드)을 가진다는 뜻. 이는 출력 차원이 1임을 의미함.
<br>input_shape=[1,]: 입력 데이터의 형태를 정의함. 이 경우, 입력은 하나의 특성(1차원)을 가진 단일 값.
<br>activation=None: 활성화 함수가 없음. 즉, 선형 활성화 함수를 사용함.
<br>
<br>model.summary()<br>
모델의 구조를 요약하여 출력하는 함수. 모델의 각 레이어와 그 레이어의 파라미터 수를 보여줌.
<br><img alt="output_1.png" src="lib\media\output_1.png"><br><img alt="output_2.png" src="lib\media\output_2.png"><br><img alt="output_3.png" src="lib\media\output_3.png"><br><img alt="output_4.png" src="lib\media\output_4.png"><br><img alt="output_5.png" src="lib\media\output_5.png"><br>
<br>Total params: 모델 전체의 학습 가능한 파라미터 수.
<br>Trainable params: 학습 가능한(즉, 훈련 중에 업데이트되는) 파라미터 수.
<br>Non-trainable params: 학습 불가능한 파라미터 수입니다. 이는 훈련 중에 업데이트되지 않는 파라미터.
<br>파라미터가 2인 이유는 가중치(W)의 갯수인 1 + 편향(b)의 갯수인 1을 더해 2이며<br>단순 퍼셉트론으로 학습시켰기에 전부 학습에 사용된 모습<br><img alt="code_5.png" src="lib\media\code_5.png"><br>
<br>model.compile: 모델을 학습하기 위한 손실 함수와 최적화 알고리즘을 설정합니다.
<br>손실 함수 (loss function): 모델이 예측한 값과 실제 값 간의 차이를 측정하는 함수. 이 차이를 최소화하는 방향으로 모델이 학습시킴.<br>mean_squared_error: 평균 제곱 오차(MSE) 손실 함수. 이는 회귀 문제에서 자주 사용되는 손실 함수로, 실제 값과 예측 값 간의 차이의 제곱을 평균한 값.<br>최적화 알고리즘 (optimizer): 손실 함수를 최소화하기 위해 모델의 파라미터를 업데이트하는 알고리즘.<br>sgd: 확률적 경사 하강법(Stochastic Gradient Descent) 최적화 알고리즘. 이는 각 배치에 대해 경사를 계산하고 파라미터를 업데이트함. 경사 하강법은 손실 함수를 최소화하기 위해 사용됩니다.<br><img alt="code_6.png" src="lib\media\code_6.png"><br>
<br>model.fit: 모델을 주어진 데이터로 학습시킵니다. 입력 데이터, 에포크 수, 배치 크기, 출력 형식, 검증 데이터 비율을 설정하여 모델을 학습합니다.
<br>x : 독립 변수<br>
y : 종속 변수<br>epochs : 전체 데이터셋에 대해 학습을 반복하는 횟수<br>
batch_size : 한 번에 처리하는 데이터 샘플의 수<br>
verbose : 학습 과정의 출력을 설정. 1은 학습의 진행 상황을 자세히 출력.<br>
validation_split : 주어진 학습 데이터를 검증 데이터로 사용. 모델의 일반화 성능을 평가하기 위해 학습 도중 검증 데이터를 사용.<br><br>확률적 경사 하강법(Stochastic Gradient Descent, SGD)은 경사 하강법의 변형으로, 매 배치에서 모델의 가중치를 업데이트하는 최적화 알고리즘입니다. 일반적인 경사 하강법은 전체 데이터셋을 사용하여 경사를 계산하고 가중치를 업데이트하는 반면, SGD는 매 배치(batch)에 대해 경사를 계산하고 가중치를 업데이트합니다. 이는 여러 장점이 있습니다:<br>
<br>빠른 학습 속도: 전체 데이터셋이 아니라 배치 단위로 경사를 계산하기 때문에 한 번의 업데이트가 더 빠르게 이루어집니다.
<br>더 나은 일반화: 매 배치에서 경사를 계산하기 때문에 일부 노이즈가 포함되어 더 나은 일반화 성능을 가질 수 있습니다.
<br>더 적은 메모리 사용: 전체 데이터셋을 메모리에 로드할 필요 없이 배치 단위로 처리하므로 메모리 사용량이 줄어듭니다.
<br><br>verbose는 모델 학습 과정에서 출력되는 로그의 상세 정도를 제어하는 옵션입니다. Keras에서는 verbose 파라미터에 따라 학습 진행 상황이 다르게 출력됩니다. 주요 값과 그 의미는 다음과 같습니다:<br>
<br>verbose=0: 학습 진행 상황을 출력하지 않습니다. 아무런 로그도 출력되지 않으므로 조용하게 학습이 진행됩니다.
<br>verbose=1: 자세히 학습 진행 상황을 출력합니다. 각 에포크(epoch)마다 진행 바(progress bar)와 함께 손실 값, 지표 값 등이 출력됩니다.
<br>verbose=2: 간단히 학습 진행 상황을 출력합니다. 각 에포크마다 진행 바 없이 에포크 번호와 손실 값, 지표 값 등이 출력됩니다.
<br><img alt="output_6.png" src="lib\media\output_6.png"><br><img alt="code_7.png" src="lib\media\code_7.png"><br>predict 함수를 사용하여 주어진 입력에 대한 예측 값을 얻을 수 있음<br><img alt="code_8.png" src="lib\media\code_8.png"><br><img alt="output_7.png" src="lib\media\output_7.png"><br><br>위의 예시는 입력과 출력이 한개일때의 간단한 예시이며, 선형일 때의 예시이다.<br><br>위의 방정식처럼 활성화 함수가 L개, 즉 다중/다변량 함수일 때,<br>위의 예시처럼 선형일 경우에는 굳이 신경망에 다중계층을 추가하지 않고, 단순 퍼셉트론처럼 구할 수 있을 것이다. 하지만 독립변수와 종속변수가 서로 비선형으로 연계되어 있을 경우는 비선형 함수를 사용하여 문제를 풀어볼수 있을 것이다.<br><img alt="code1 1.png" src="lib\media\code1-1.png"><br>seaborn은 파이썬의 데이터 시각화 라이브러리로, 통계적 그래프를 생성하는 데 주로 사용됩니다. seaborn은 matplotlib를 기반으로 만들어졌으며, 데이터 분석과 시각화를 더 쉽게 만들어줍니다.<br><img alt="code2 1.png" src="lib\media\code2-1.png"><br><a data-tooltip-position="top" aria-label="https://archive.ics.uci.edu/dataset/9/auto+mpg" rel="noopener nofollow" class="external-link" href="https://archive.ics.uci.edu/dataset/9/auto+mpg" target="_blank">Auto MPG - UCI Machine Learning Repository</a><br><img alt="code3 1.png" src="lib\media\code3-1.png"><br>교제에는 <br>data = data.drop('origin, 1')
Run<br>로 적혀 있는데, 파라미터 수 오류로 동작하지 않아 해당 방법으로 작성함<br>데이터에서 origin 값은 사용하지 않기 위해서 사용용<br><img alt="code4 1.png" src="lib\media\code4-1.png"><br>데이터중 20퍼는 test 데이터로 사용하기 위해서서<br><img alt="code5 1.png" src="lib\media\code5-1.png"><br>kde는 kernel density estimation의 약자로, 커널 밀도 추정(kernel density estimation)을 의미합니다. pairplot에서 diag_kind=kde 옵션을 사용하면 대각선에 위치한 각 변수의 분포를 커널 밀도 그래프로 나타낼 수 있습니다.<br>커널 밀도 추정은 데이터의 분포를 부드럽게 나타내는 방법 중 하나로, 각 데이터 포인트를 중심으로 커널(일종의 함수)을 배치하여 전체 데이터의 분포를 추정합니다. 이렇게 추정된 밀도는 매끄럽고 연속된 형태로 표현되며, 히스토그램보다 데이터 분포를 더 정확하게 시각화할 수 있습니다.<br>따라서 diag_kind=kde를 설정하면 pairplot의 대각선 위치에 각 변수의 커널 밀도 그래프가 표시됩니다. 이를 통해 각 변수가 어떻게 분포되어 있는지를 시각적으로 파악할 수 있습니다.<br><img alt="code6.png" src="lib\media\code6.png"><br><img alt="code7.png" src="lib\media\code7.png"><br>mpg 값을 추론하기 위함이기에 mpg값 제거<br><img alt="code8.png" src="lib\media\code8.png"><br>너무 큰 값은 데이터의 범위를 초과할 수 있기에 0~1사이의 사이즈로 정규화해주는 nomarlization함수를 사용<br><img alt="code9.png" src="lib\media\code9.png"><br>3개의 은닉층을 생성성<br><img alt="code10.png" src="lib\media\code10.png"><br><img alt="code11.png" src="lib\media\code11.png"><br><img alt="code12.png" src="lib\media\code12.png"><br><img alt="code13.png" src="lib\media\code13.png"><br><img alt="code14.png" src="lib\media\code14.png"><br> '?'는 모델이 아직 빌드되지 않았기 때문에 정확한 출력 형태가 알려지지 않았음을 의미합니다. <br> 모델을 빌드하고 나면 입력 데이터에 따라서 각 레이어의 출력 형태가 결정됩니다.<br>출력값이 '?'로 나오는 것은 모델이 아직 빌드되지 않았기 때문입니다. Total params와 Trainable params는 normalization 레이어의 파라미터들을 포함하고 있으며, Non-trainable params는 이러한 파라미터들이 학습되지 않는다는 것을 나타냅니다. 모델을 빌드하고 학습시키면 이러한 값들이 실제로 결정되고 출력됩니다.<br><img alt="code15.png" src="lib\media\code15.png"><br>adam은 신경망 학습에서 사용되는 최적화 알고리즘 중 하나입니다. Adam은 Adaptive Moment Estimation의 줄임말로, 경사 하강법의 변형 알고리즘입니다. Adam은 RMSProp(제곱 평균 민감도)과 모멘텀(gradient descent with momentum)을 결합한 방법으로, 다음과 같은 특징을 가집니다:<br>
<br>자동적인 학습률 조정: Adam은 각 파라미터에 대해 학습률을 자동으로 조정합니다. 각 파라미터에 대해 변화의 평균과 제곱 평균을 추정하여 학습률을 조정하는 데 사용합니다.
<br>모멘텀 방법 사용: 이전 그래디언트의 지수 가중 평균을 사용하여 모멘텀을 추가합니다. 이는 학습 속도를 빠르게 하고 지역 최솟값에서의 탈출을 돕습니다.
<br>제곱 그래디언트의 지수 가중 평균: RMSProp과 유사하게, 제곱 그래디언트의 지수 가중 평균을 사용하여 각 파라미터마다 다른 학습률을 적용합니다.
<br>Adam은 다양한 종류의 신경망 문제에서 잘 작동하며, 일반적으로 학습 속도가 빠르고 성능이 우수하다는 장점이 있습니다. 주어진 문제와 데이터셋에 따라 다른 최적화 알고리즘도 사용할 수 있지만, Adam은 많은 경우에서 좋은 선택지입니다.<br><img alt="code16.png" src="lib\media\code16.png"><br><img alt="code17.png" src="lib\media\code17.png"><br><img alt="code18.png" src="lib\media\code18.png"><br><img alt="code19.png" src="lib\media\code19.png"><br>위에서<br>data = data.drop('origin, 1')
Run<br>로 고쳐 사용한 것에서 문제가 발생한것으로 추론<br>교제의 값보다 휠씬 크게 데이터의 값의 편차가 나옴옴<br><img alt="code20.png" src="lib\media\code20.png"><br>y_pred의 크기로 78로 나와야 하나 2496개의 데이터가 나왔고,<br>이는 78 * 78의 사이즈였기에  0번째 index의 값들만을 사용하여 데이터를 비교하였음<br><img alt="code21.png" src="lib\media\code21.png"><br><img alt="code22.png" src="lib\media\code22.png"><br><img alt="code23.png" src="lib\media\code23.png"><br><br><br>
<br>목적: 입력 데이터가 특정 클래스나 범주에 속하는지 예측합니다.
<br>출력 값: 이산 값(Discrete values). 예를 들어, 스팸 이메일 여부(스팸/스팸 아님), 암 진단(양성/음성), 이미지 분류(고양이/개/새 등) 등이 있습니다.
<br>모델 예: 로지스틱 회귀, 서포트 벡터 머신, 결정 트리, 랜덤 포레스트, k-최근접 이웃, 신경망, 나이브 베이즈 등.
<br>평가 지표: 정확도(Accuracy), 정밀도(Precision), 재현율(Recall), F1-score, AUC-ROC 곡선 등.
<br><br>
<br>목적: 입력 데이터와 연속적인 값을 예측합니다.
<br>출력 값: 연속 값(Continuous values). 예를 들어, 주택 가격 예측, 주식 가격 예측, 기온 예측 등이 있습니다.
<br>모델 예: 선형 회귀, 다중 선형 회귀, 다항 회귀, 서포트 벡터 회귀, 결정 트리 회귀, 랜덤 포레스트 회귀, 신경망 등.
<br>평가 지표: 평균 제곱 오차(MSE), 평균 절대 오차(MAE), R² 점수 등.
<br><br>
<br>출력 유형:

<br>분류: 클래스 레이블(이산 값).
<br>회귀: 실수 값(연속 값).


<br>목적:

<br>분류: 데이터가 어떤 범주에 속하는지 예측.
<br>회귀: 데이터의 특정 수치 값을 예측.


<br><img alt="예시.png" src="lib\media\예시.png"><br>
분류의 목표는 0과 1을 구분하는 선을 긋는 것이고<br><img alt="예시2.png" src="lib\media\예시2.png"><br>
회귀의 목표는 주어진 점에 최대한 근사한 선을 그리는 것이다.<br><br>목적: 이진 분류 문제를 해결하기 위해 사용되는 통계 모델.<br>
<br>특징:

<br>입력 변수와 출력 변수 간의 관계를 모델링하여, 특정 클래스에 속할 확률을 예측합니다.
<br>선형 회귀와 유사하지만, 출력이 확률값(0에서 1 사이)이 되도록 하는 것이 차이점입니다.


<br>수식:

<br>예측 함수: 
<br>여기서 σ는 시그모이드 함수, w는 가중치 벡터, x는 입력 벡터, b는 편향입니다.


<br><br>로지스틱 회귀는 이진 분류 문제를 해결하는 데 주로 사용됩니다. 이 모델은 주어진 입력 데이터가 특정 클래스에 속할 확률을 예측합니다. 이를 통해 데이터 포인트가 어느 클래스에 속하는지를 분류합니다.<br><br>로지스틱 회귀는 선형 회귀와 달리, 출력이 실수가 아닌 확률값이 됩니다. 이 확률값을 사용하여 분류 결정을 내릴 수 있습니다. 이를 가능하게 하는 것이 시그모이드 함수입니다.<br><br>목적: 실수 값을 [0, 1] 사이의 확률값으로 변환하는 비선형 함수.<br>
<br>특징:

<br>S자 형태의 곡선으로, 입력값을 확률값으로 변환합니다.
<br>출력이 0과 1 사이의 값이므로, 확률을 모델링할 때 유용합니다.


<br>수식:

<br>시그모이드 함수: 
<br>여기서 는 로지스틱 회귀의 선형 조합입니다.


<br>그래프:

<br>z가 큰 양수일 때, σ(z)는 1에 가까워지고, 큰 음수일 때는 0에 가까워집니다.


<br><br>목적: 분류 모델의 성능을 평가하기 위한 손실 함수.<br>
<br>특징:

<br>모델의 예측 확률 분포와 실제 레이블 간의 차이를 측정합니다.
<br>예측이 실제 레이블과 더 가까울수록 손실이 작아집니다.


<br>수식:

<br>교차 엔트로피 손실: 
<br>여기서 ​는 실제 레이블(0 또는 1), ​는 예측 확률입니다.


<br>위에서 언급했듯 로지스틱 회귀는 이진 분류의 역할을 하여 2가지만 분류할 수 있지만 One-Versus-All 방식, Softmax 회귀(Softmax Regression); 다항 로지스틱 회귀(Multinomial Logistic Regression)방식을 사용하면 두개 이상도 분류할 수 있다. 그 중 교제에 나온 One-Versus-All 방식은 다음과 같이 진행된다.<br><br>목적: 다중 클래스 분류 문제를 해결하기 위한 전략.<br>
<br>특징:

<br>다중 클래스 분류 문제를 여러 개의 이진 분류 문제로 변환합니다.
<br>각 클래스에 대해 해당 클래스와 나머지 모든 클래스를 구분하는 이진 분류기를 학습합니다.


<br>예시:

<br>3개의 클래스(A, B, C)가 있는 경우, 세 개의 이진 분류기를 학습합니다:

<br>분류기 1: 클래스 A와 나머지(B, C) 구분
<br>분류기 2: 클래스 B와 나머지(A, C) 구분
<br>분류기 3: 클래스 C와 나머지(A, B) 구분


<br>새로운 데이터 포인트를 예측할 때는, 각 분류기의 출력을 비교하여 가장 높은 확률을 반환하는 클래스를 선택합니다.


<br><br><img alt="1.png" src="lib\media\1.png"><br><img alt="2.png" src="lib\media\2.png"><br>mnist는 1장에서도 하였던 필기체 데이터임<br><img alt="3.png" src="lib\media\3.png"><br>데이터의 자료형을 32비트 float, 32비트 int형으로 만들어 주고,<br>
데이터에 대해서는 1미만이 될 수 있도록 255로 나눠어줌줌<br><img alt="4.png" src="lib\media\4.png"><br>로지스트 회귀를 시험하기 위해 시그모이드 함수만을 사용함함<br><img alt="5.png" src="lib\media\5.png"><br><img alt="6.png" src="lib\media\6.png"><br><img alt="7.png" src="lib\media\7.png"><br><img alt="8.png" src="lib\media\8.png"><br><img alt="9.png" src="lib\media\9.png"><br><img alt="10.png" src="lib\media\10.png"><br>
<br>SparseCategoricalCrossentropy: 이 손실 함수는 다중 클래스 분류 문제에서 사용됩니다. Sparse는 정수 형식의 라벨 (sparse label)을 다루기 위해 사용됩니다.<br>

<br>from_logits=True: 모델의 출력이 확률 값이 아니라 logits (로그-오즈 비율)로 제공될 때 사용됩니다. logits는 확률을 계산하기 전에 softmax 함수를 통해 변환되어야 합니다. 따라서 from_logits=True를 설정하면 내부적으로 softmax 함수를 사용하여 logits를 확률로 변환하고 손실을 계산합니다.
<br><img alt="11.png" src="lib\media\11.png"><br><img alt="12.png" src="lib\media\12.png"><br><img alt="13.png" src="lib\media\13.png"><br>현재의 그래프를 보면, 훈련 손실이 감소할수록, 검증 손실은 증가하는 데, 이것을 과적합 상태라고 하며, 머신러닝 모델이 훈련 데이터에 너무 잘 맞춰져서 새로운 데이터(테스트 데이터)에 대해 일반화하지 못하는 현상을 말합니다. 이는 모델이 훈련 데이터의 노이즈나 세부 사항까지 학습해버려, 새로운 데이터에서 성능이 떨어지는 상황을 초래합니다.<br><br>
<br>훈련 데이터에서의 높은 성능: 모델이 훈련 데이터에서는 매우 높은 정확도를 보입니다.
<br>테스트 데이터에서의 낮은 성능: 그러나 모델이 보지 못한 새로운 데이터에서는 성능이 크게 떨어집니다.
<br><br>
<br>복잡한 모델: 너무 많은 파라미터를 가진 복잡한 모델은 훈련 데이터의 세부 사항까지 학습할 수 있습니다.
<br>적은 양의 데이터: 데이터가 적으면 모델이 데이터의 패턴 대신 노이즈를 학습할 가능성이 높아집니다.
<br>훈련 데이터의 노이즈: 데이터 자체에 노이즈가 많으면 모델이 이를 학습하게 됩니다.
<br><br>
<br>더 많은 데이터 수집: 훈련 데이터의 양을 늘려 모델이 더 일반화된 패턴을 학습하게 합니다.
<br>정규화 기법 사용: L1, L2 정규화와 같은 정규화 기법을 사용해 모델의 복잡도를 줄입니다.
<br>드롭아웃(Dropout): 신경망의 일부 뉴런을 무작위로 꺼서 학습하는 드롭아웃 기법을 사용합니다.
<br>교차 검증: 교차 검증을 통해 모델의 일반화 성능을 평가하고 최적의 모델을 선택합니다.
<br><img alt="14.png" src="lib\media\14.png"><br><img alt="15.png" src="lib\media\15.png"><br><img alt="16.png" src="lib\media\16.png"><br>확률을 보면, 4일 확률이 높지만, 다른 확률로 값이 적지 않다.<br><img alt="17.png" src="lib\media\17.png"><br>SparseCategoricalCrossentropy에서 softmax를 자체적으로 사용하나, softmax을 사용하는 것을 권장하였다. 책에서 주어진 은닉층이 2개인 경우이다.<br><img alt="18.png" src="lib\media\18.png"><br><img alt="19.png" src="lib\media\19.png"><br><img alt="20.png" src="lib\media\20.png"><br><img alt="21.png" src="lib\media\21.png"><br><img alt="22.png" src="lib\media\22.png"><br><img alt="23.png" src="lib\media\23.png"><br>이전에는 다른 값일 확률이 있었으나, 현제는 오로지 4일 확률만 존재한다.]]></description><link>공부\coding\tensorflow-딥러닝\2장-회귀와-분류.html</link><guid isPermaLink="false">공부/coding/tensorflow 딥러닝/2장 회귀와 분류.md</guid><pubDate>Thu, 18 Jul 2024 05:24:23 GMT</pubDate><enclosure url="lib\media\code1-1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\code1-1.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[3장 컨볼루션 신경망]]></title><description><![CDATA[ 
 <br>동물의 시각 피질에 구조에서 영감을 받다 만들어진 딥러닝 신경망 모델<br>시각 자극이 1차 시각피질, 2차 시각피질, 3차 시각피질을 통과하여 계층적 정보처리 <br>CNN은<br>
전반부 : 컨볼루션 연산을 통해 특징을 추출함  (컨볼루션)<br>
차원을 감소시키며, 적은 영역으로 쪼개어 쪼개진 부분이 어떤 특징을 가졌는지 추출함<br>후반부 : 특징을 통한 분류 진행  (다층 퍼셉트론)<br>
감소되 차원을 다시 합치는 과정을 통해 분류된 특징을 분류함<br>영상분류, 문자인식 등, 인식문제에 높은 성능을 가짐<br>ex)<br>
<img alt="Pasted image 20240730165343.png" src="lib\media\pasted-image-20240730165343.png"><br>| (세로) 필터<br>
<img alt="Pasted image 20240730165358.png" src="lib\media\pasted-image-20240730165358.png"><br>
가로선(-) 특징<br>
<img alt="Pasted image 20240730165415.png" src="lib\media\pasted-image-20240730165415.png"><br><br>2차원 그림을 부분 행렬로 하여, 인접한 행렬을 다음 계층의 1개의 은닉 뉴런과 연결하는 것<br>이 은닉 뉴런이 지역 수용 필드이다<br><br>이 표를 기준으로<br><br>이 표(커널)와 1이 겹치는 갯수로 표를 만들면 다음과 같다<br><br>핵심은 전체 집합에서 이미 검사한 부분 집합도 다시 사용된다는 것이다.<br>
<img alt="img1.daumcdn.gif" src="lib\media\img1.daumcdn.gif"><br>
(1칸씩 이동하기에 스트라이드는 1)<br>
커널을 통해 추출한 이미지의 특징을 활성화 맵이라고 한다.<br>ex)<br>
edge detection kernel : 선만 추출<br><br>sharpen kernel : 특징 강화<br><br>box blur kernel : 전체적으로 블러처리<br><br>과거에는 이런 특징을 얻는 커널을 filter bank라는 곳에 저장하여 사용했었음<br>색의 대비, 가로선, 세로선, 대각선들을 통해 물체의 모양을 유추하고, 이를 통하여 분류를 진행함<br>현재는 이 필터들을  CNN이 처리함<br><a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=G0kzSRbNF6E" target="_blank">https://www.youtube.com/watch?v=G0kzSRbNF6E</a><br>왜 활성화 맵을 만드는가?<br>원본 이미지로 학습시키는 것에 비해, 특징만을 추출하여 비교한다면 비교가 더 쉬울것임<br>풀링에는 최댓값, 최소값, 평균값 폴링이 존재함<br>사용하는 이유는 차원의 축소로 연산량 감소<br>
이미지의 강한 특징만을 추출<br>ex)<br>
모서리 추출에서 max 풀링 연산시 모서리에 대한 특징만 강하게 남을 것임+ 차원 축소<br>컨볼루션이 진행된 후에는 항상 폴링이 번갈아 동작해야 한다.<br><img alt="Pasted image 20240730162847.png" src="lib\media\pasted-image-20240730162847.png"><br>F는 필터의 크기, P는 패딩의 크기, S는 스트라이드를 의미<br>스트라이드는 컨볼루션 연산시 건너뛰는 정도를 의미<br>
스트라이드가 클시 이미지를 확 넘어가면 차원이 많이 축소됨<br>패딩은 나머지 연산을 진행 했을때, 차원이 정수로 나누어 떨어지지 않을 수 있는데, 이때, 이미지의 외각에 P만큼 0을 채워주는 zero-padding을 적용<br><img alt="Pasted image 20240730163233.png" src="lib\media\pasted-image-20240730163233.png"><br>
출력 이미지는 위의 수식과 동일하다고 생각하면 됨<br><img alt="Pasted image 20240730163627.png" src="lib\media\pasted-image-20240730163627.png"><br>ex)<br>
의 mnist이미지에  크기의 필터에 스트라이드가 2이고, 제로 패딩을 1회 적용, 필터의 갯수가 64개라면<br><img alt="Pasted image 20240730163525.png" src="lib\media\pasted-image-20240730163525.png"><br> 크기의 64개의 활성화 맵이 추출될 것<br><img alt="Pasted image 20240730165736.png" src="lib\media\pasted-image-20240730165736.png">]]></description><link>공부\coding\tensorflow-딥러닝\3장-컨볼루션-신경망.html</link><guid isPermaLink="false">공부/coding/tensorflow 딥러닝/3장 컨볼루션 신경망.md</guid><pubDate>Sat, 14 Dec 2024 11:44:26 GMT</pubDate><enclosure url="lib\media\pasted-image-20240730165343.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src=&quot;lib\media\pasted-image-20240730165343.png&quot;&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[4장 단어 임베딩]]></title><description><![CDATA[ 
 <br>자연어 처리의 기초<br>단어를 숫자로 변환(이를 벡터화라고 함)<br>
초기에는 이를 원핫 인코딩으로 해결 했음<br>단어를 벡터화하면 원점을 기준으로 두 벡터의 내적을 구할 수 있게 되고, 그 각도가 가장 작은 것이 유사한 단어인 것이다. 그러기에 각도가 0이라는 것은 완전히 유사한 개념이라고 볼 수 있을 것이다.<br>인핫 인코딩의 문제점은 접곱으로 내적을 구하기에 x, y좌표중 한개라도 0이라면,  점곱또한 0이 됨으로 잘못된 결과가 도출된다.<br>이러한 한계를 극복하기 위해 문서를 문맥으로 사용하여 텍스트를 벡터화하는 정보 검색 기술을 사용한다.<br>핵심 기술은<br>
빈도-역문서 빈도(TF-IDF; term, frequency-inverse document frequency)<br>
잠재 문맥 분석(LSA; Lastent Semantic Analysis)<br>
주제 모델링이 있다.<br>해당 방식들은 단어간의 의미적 유사성에 대한 문서 중심적 아이디어를 포착하려 시도한다.<br>오늘날의 인베딩은 텍스트 분류, 문서 클러스트링, 음성 태그 지정, 명명된 개체 인식, 감정분석등 모든 NLP작업의 기본 기술이다.<br>이 기술은 분포 가설에 기반하여 만들어 졌으며, 유사한 맥락에서 등장하는 단어들은 비슷한 의미를 가진다는 경향이 있다는 뜻이다.<br>그러기에 단어 임베딩 기반의 인코딩 부류들을 분산표현이라고 하기도 한다.<br><br>파리는 프랑스의 수도다.<br>
베를린은 독일의 수도다.<br>이 두 문장에서 단 한개의 단어를 알지 못하더라도<br>
파리와 프랑스는 연관이 있고,<br>
베를린과 독일은 연관이 있고,<br>
파리와 베를린은 연관이 있다는 느낌은 알 수 있을 것이다.<br>분산 임베딩 공간은 유사한 문맥에서 사용된 단어들은 서로 가까운 공간상에 위치한다는 것이다.<br><br>단어를 키 값으로 가지고, 해당 벡터를 값으로 가지는 것,<br>단어를 키값으로 가지는 것 때문에 중의어에 대해서는 처리할 수 없다.]]></description><link>공부\coding\tensorflow-딥러닝\4장-단어-임베딩.html</link><guid isPermaLink="false">공부/coding/tensorflow 딥러닝/4장 단어 임베딩.md</guid><pubDate>Fri, 26 Jul 2024 12:43:03 GMT</pubDate></item><item><title><![CDATA[5장 순환신경망]]></title><description><![CDATA[ 
 <br>CNN은 이미지에 주로 사용되며<br>RNN은 유연하여 음성 인식, 언어 모델링, 기계번역, 감정분석 및 이미지 처리등에 사용된다<br>RNN의 컨셉은 모든 입력은 순차적이라는 것을 이용한다.<br>한 입력에 대하여, 음성이던 텍스트이던 이전의 입력 값이 존재하며, 이전에 발생한 요소들이 모두 순차입력이 될 수 있다.]]></description><link>공부\coding\tensorflow-딥러닝\5장-순환신경망.html</link><guid isPermaLink="false">공부/coding/tensorflow 딥러닝/5장 순환신경망.md</guid><pubDate>Fri, 26 Jul 2024 12:49:47 GMT</pubDate></item><item><title><![CDATA[index]]></title><description><![CDATA[ 
 <br>14:29:42월요일, 3월 17, 2025<br><br>
<br>
dayshoursminutesseconds정보처리 기사 필기

<br>
<br><br>
<br>수학

<br><a data-href="계차와 누적합" href="공부\수학\계산-기하학\계차와-누적합.html" class="internal-link" target="_self" rel="noopener nofollow">계차와 누적합</a>
<br><a data-href="벡터" href="공부\수학\계산-기하학\벡터.html" class="internal-link" target="_self" rel="noopener nofollow">벡터</a>
<br><a data-href="미분" href="공부\수학\미적분\미분.html" class="internal-link" target="_self" rel="noopener nofollow">미분</a>
<br><a data-href="적분" href="공부\수학\미적분\적분.html" class="internal-link" target="_self" rel="noopener nofollow">적분</a>
<br><a data-href="모듈러 역수" href="공부\수학\모듈러-역수.html" class="internal-link" target="_self" rel="noopener nofollow">모듈러 역수</a>
<br><a data-href="몬테카를로법" href="공부\수학\몬테카를로법.html" class="internal-link" target="_self" rel="noopener nofollow">몬테카를로법</a>
<br><a data-href="행렬" href="공부\수학\행렬.html" class="internal-link" target="_self" rel="noopener nofollow">행렬</a>


<br>그래프 알고리즘

<br><a data-href="깊이 우선 탐색" href="공부\알고리즘\그래프-알고리즘\깊이-우선-탐색.html" class="internal-link" target="_self" rel="noopener nofollow">깊이 우선 탐색</a>
<br><a data-href="너비 우선 탐색" href="공부\알고리즘\그래프-알고리즘\너비-우선-탐색.html" class="internal-link" target="_self" rel="noopener nofollow">너비 우선 탐색</a>
<br><a data-href="벨만-포드 알고리즘" href="공부\알고리즘\그래프-알고리즘\벨만-포드-알고리즘.html" class="internal-link" target="_self" rel="noopener nofollow">벨만-포드 알고리즘</a>
<br><a data-href="존슨 알고리즘" href="공부\알고리즘\그래프-알고리즘\존슨-알고리즘.html" class="internal-link" target="_self" rel="noopener nofollow">존슨 알고리즘</a>
<br><a data-href="코사라주 알고리즘" href="공부\알고리즘\그래프-알고리즘\코사라주-알고리즘.html" class="internal-link" target="_self" rel="noopener nofollow">코사라주 알고리즘</a>


<br>정렬 알고리즘

<br><a data-href="병합 정렬" href="공부\알고리즘\정렬\분할정복\병합-정렬.html" class="internal-link" target="_self" rel="noopener nofollow">병합 정렬</a>
<br><a data-href="선형 시간 선택" href="공부\알고리즘\정렬\분할정복\선형-시간-선택.html" class="internal-link" target="_self" rel="noopener nofollow">선형 시간 선택</a>
<br><a data-href="퀵 정렬" href="공부\알고리즘\정렬\분할정복\퀵-정렬.html" class="internal-link" target="_self" rel="noopener nofollow">퀵 정렬</a>
<br><a data-href="이진 검색" href="공부\알고리즘\정렬\이진-검색.html" class="internal-link" target="_self" rel="noopener nofollow">이진 검색</a>


<br>그 외

<br><a data-href="동적 계획법" href="공부\알고리즘\동적-계획법.html" class="internal-link" target="_self" rel="noopener nofollow">동적 계획법</a>
<br><a data-href="메모이제이션" href="공부\알고리즘\메모이제이션.html" class="internal-link" target="_self" rel="noopener nofollow">메모이제이션</a>
<br><a data-href="백트래킹" href="공부\알고리즘\백트래킹.html" class="internal-link" target="_self" rel="noopener nofollow">백트래킹</a>
<br><a data-href="브루트 포스(Brute force)" href="공부\알고리즘\브루트-포스(brute-force).html" class="internal-link" target="_self" rel="noopener nofollow">브루트 포스(Brute force)</a>
<br><a data-href="에라토스네스의 체" href="공부\알고리즘\에라토스네스의-체.html" class="internal-link" target="_self" rel="noopener nofollow">에라토스네스의 체</a>
<br><a data-href="최대공약수" href="공부\알고리즘\최대공약수.html" class="internal-link" target="_self" rel="noopener nofollow">최대공약수</a>
<br><a data-href="해싱" href="공부\알고리즘\해싱.html" class="internal-link" target="_self" rel="noopener nofollow">해싱</a>
<br><a data-href="KMP 알고리즘" href="공부\알고리즘\kmp-알고리즘.html" class="internal-link" target="_self" rel="noopener nofollow">KMP 알고리즘</a>
<br><a data-href="LCS(Longest common subsequence; 최장 공통 부분 수열)" href="공부\알고리즘\lcs(longest-common-subsequence;-최장-공통-부분-수열).html" class="internal-link" target="_self" rel="noopener nofollow">LCS(Longest common subsequence; 최장 공통 부분 수열)</a>


]]></description><link>index.html</link><guid isPermaLink="false">index.md</guid><pubDate>Mon, 17 Mar 2025 05:29:00 GMT</pubDate></item></channel></rss>